<FUNCTION>
<NAME>as_release_get_description_table</NAME>
<RETURNS>GHashTable 	*</RETURNS>
AsRelease *release
</FUNCTION>
<FUNCTION>
<NAME>as_data_pool_scan_apt</NAME>
<RETURNS>void 		</RETURNS>
AsDataPool *dpool, gboolean force, GError **error
</FUNCTION>
<FUNCTION>
<NAME>as_is_spdx_license_id</NAME>
<RETURNS>gboolean 	 </RETURNS>
const gchar *license_id
</FUNCTION>
<FUNCTION>
<NAME>as_is_spdx_license_expression</NAME>
<RETURNS>gboolean 	 </RETURNS>
const gchar *license
</FUNCTION>
<FUNCTION>
<NAME>as_spdx_license_tokenize</NAME>
<RETURNS>gchar 		**</RETURNS>
const gchar *license
</FUNCTION>
<FUNCTION>
<NAME>as_spdx_license_detokenize</NAME>
<RETURNS>gchar 		*</RETURNS>
gchar **license_tokens
</FUNCTION>
<FUNCTION>
<NAME>as_license_to_spdx_id</NAME>
<RETURNS>gchar 		*</RETURNS>
const gchar *license
</FUNCTION>
<FUNCTION>
<NAME>as_license_is_metadata_license</NAME>
<RETURNS>gboolean 	</RETURNS>
const gchar *license
</FUNCTION>
<FUNCTION>
<NAME>as_description_markup_convert_simple</NAME>
<RETURNS>gchar 		*</RETURNS>
const gchar *markup
</FUNCTION>
<FUNCTION>
<NAME>as_get_current_locale</NAME>
<RETURNS>gchar 		*</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>as_str_empty</NAME>
<RETURNS>gboolean 	</RETURNS>
const gchar* str
</FUNCTION>
<FUNCTION>
<NAME>as_iso8601_to_datetime</NAME>
<RETURNS>GDateTime 	*</RETURNS>
const gchar *iso_date
</FUNCTION>
<FUNCTION>
<NAME>as_utils_locale_is_compatible</NAME>
<RETURNS>gboolean 	</RETURNS>
const gchar *locale1, const gchar *locale2
</FUNCTION>
<FUNCTION>
<NAME>as_utils_is_category_name</NAME>
<RETURNS>gboolean 	</RETURNS>
const gchar *category_name
</FUNCTION>
<FUNCTION>
<NAME>as_utils_is_tld</NAME>
<RETURNS>gboolean 	</RETURNS>
const gchar *tld
</FUNCTION>
<MACRO>
<NAME>AS_TYPE_YAMLDATA</NAME>
#define AS_TYPE_YAMLDATA (as_yamldata_get_type ())
</MACRO>
<STRUCT>
<NAME>AsYAMLDataClass</NAME>
struct _AsYAMLDataClass
{
	GObjectClass		parent_class;
	/*< private >*/
	void (*_as_reserved1)	(void);
	void (*_as_reserved2)	(void);
	void (*_as_reserved3)	(void);
	void (*_as_reserved4)	(void);
	void (*_as_reserved5)	(void);
	void (*_as_reserved6)	(void);
};
</STRUCT>
<FUNCTION>
<NAME>as_yamldata_new</NAME>
<RETURNS>AsYAMLData 		*</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>as_yamldata_initialize</NAME>
<RETURNS>void 			</RETURNS>
AsYAMLData *ydt, const gchar *locale, const gchar *origin, const gchar *media_baseurl, const gchar *arch, gint priority
</FUNCTION>
<FUNCTION>
<NAME>as_yamldata_parse_distro_data</NAME>
<RETURNS>GPtrArray 		*</RETURNS>
AsYAMLData *ydt, const gchar *data, GError **error
</FUNCTION>
<FUNCTION>
<NAME>as_yamldata_serialize_to_distro</NAME>
<RETURNS>gchar 			*</RETURNS>
AsYAMLData *ydt, GPtrArray *cpts, gboolean write_header, gboolean add_timestamp, GError **error
</FUNCTION>
<FUNCTION>
<NAME>as_yamldata_get_locale</NAME>
<RETURNS>const gchar 		*</RETURNS>
AsYAMLData *ydt
</FUNCTION>
<FUNCTION>
<NAME>as_yamldata_set_locale</NAME>
<RETURNS>void 			</RETURNS>
AsYAMLData *ydt, const gchar *locale
</FUNCTION>
<FUNCTION>
<NAME>as_yamldata_set_check_valid</NAME>
<RETURNS>void 			</RETURNS>
AsYAMLData *ydt, gboolean check
</FUNCTION>
<STRUCT>
<NAME>AsYAMLData</NAME>
</STRUCT>
<FUNCTION>
<NAME>as_screenshot_get_caption_table</NAME>
<RETURNS>GHashTable 		*</RETURNS>
AsScreenshot *screenshot
</FUNCTION>
<MACRO>
<NAME>AS_TYPE_IMAGE</NAME>
#define AS_TYPE_IMAGE (as_image_get_type ())
</MACRO>
<STRUCT>
<NAME>AsImageClass</NAME>
struct _AsImageClass
{
	GObjectClass		parent_class;
	/*< private >*/
	void (*_as_reserved1)	(void);
	void (*_as_reserved2)	(void);
	void (*_as_reserved3)	(void);
	void (*_as_reserved4)	(void);
	void (*_as_reserved5)	(void);
	void (*_as_reserved6)	(void);
};
</STRUCT>
<ENUM>
<NAME>AsImageKind</NAME>
typedef enum {
	AS_IMAGE_KIND_UNKNOWN,
	AS_IMAGE_KIND_SOURCE,
	AS_IMAGE_KIND_THUMBNAIL,
	/*< private >*/
	AS_IMAGE_KIND_LAST
} AsImageKind;
</ENUM>
<FUNCTION>
<NAME>as_image_kind_from_string</NAME>
<RETURNS>AsImageKind 	 </RETURNS>
const gchar *kind
</FUNCTION>
<FUNCTION>
<NAME>as_image_kind_to_string</NAME>
<RETURNS>const gchar 	*</RETURNS>
AsImageKind kind
</FUNCTION>
<FUNCTION>
<NAME>as_image_new</NAME>
<RETURNS>AsImage 		*</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>as_image_get_kind</NAME>
<RETURNS>AsImageKind 	 </RETURNS>
AsImage *image
</FUNCTION>
<FUNCTION>
<NAME>as_image_set_kind</NAME>
<RETURNS>void 		 </RETURNS>
AsImage *image, AsImageKind kind
</FUNCTION>
<FUNCTION>
<NAME>as_image_get_url</NAME>
<RETURNS>const gchar 	*</RETURNS>
AsImage *image
</FUNCTION>
<FUNCTION>
<NAME>as_image_set_url</NAME>
<RETURNS>void 		 </RETURNS>
AsImage *image, const gchar *url
</FUNCTION>
<FUNCTION>
<NAME>as_image_get_width</NAME>
<RETURNS>guint 		 </RETURNS>
AsImage *image
</FUNCTION>
<FUNCTION>
<NAME>as_image_set_width</NAME>
<RETURNS>void 		 </RETURNS>
AsImage *image, guint width
</FUNCTION>
<FUNCTION>
<NAME>as_image_get_height</NAME>
<RETURNS>guint 		 </RETURNS>
AsImage *image
</FUNCTION>
<FUNCTION>
<NAME>as_image_set_height</NAME>
<RETURNS>void 		 </RETURNS>
AsImage *image, guint height
</FUNCTION>
<FUNCTION>
<NAME>as_image_get_locale</NAME>
<RETURNS>const gchar 	*</RETURNS>
AsImage *image
</FUNCTION>
<FUNCTION>
<NAME>as_image_set_locale</NAME>
<RETURNS>void 		 </RETURNS>
AsImage *image, const gchar *locale
</FUNCTION>
<STRUCT>
<NAME>AsImage</NAME>
</STRUCT>
<MACRO>
<NAME>AS_TYPE_SUGGESTED</NAME>
#define AS_TYPE_SUGGESTED (as_suggested_get_type ())
</MACRO>
<STRUCT>
<NAME>AsSuggestedClass</NAME>
struct _AsSuggestedClass
{
	GObjectClass		parent_class;
	/*< private >*/
	void (*_as_reserved1)	(void);
	void (*_as_reserved2)	(void);
	void (*_as_reserved3)	(void);
	void (*_as_reserved4)	(void);
	void (*_as_reserved5)	(void);
	void (*_as_reserved6)	(void);
};
</STRUCT>
<ENUM>
<NAME>AsSuggestedKind</NAME>
typedef enum  {
	AS_SUGGESTED_KIND_UNKNOWN,
	AS_SUGGESTED_KIND_UPSTREAM,
	AS_SUGGESTED_KIND_HEURISTIC,
	/*< private >*/
	AS_SUGGESTED_KIND_LAST
} AsSuggestedKind;
</ENUM>
<FUNCTION>
<NAME>as_suggested_kind_from_string</NAME>
<RETURNS>AsSuggestedKind 			</RETURNS>
const gchar *kind_str
</FUNCTION>
<FUNCTION>
<NAME>as_suggested_kind_to_string</NAME>
<RETURNS>const gchar 			*</RETURNS>
AsSuggestedKind kind
</FUNCTION>
<FUNCTION>
<NAME>as_suggested_new</NAME>
<RETURNS>AsSuggested 			*</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>as_suggested_get_kind</NAME>
<RETURNS>AsSuggestedKind 			</RETURNS>
AsSuggested *suggested
</FUNCTION>
<FUNCTION>
<NAME>as_suggested_set_kind</NAME>
<RETURNS>void 				</RETURNS>
AsSuggested *suggested, AsSuggestedKind kind
</FUNCTION>
<FUNCTION>
<NAME>as_suggested_get_ids</NAME>
<RETURNS>GPtrArray 			*</RETURNS>
AsSuggested *suggested
</FUNCTION>
<FUNCTION>
<NAME>as_suggested_add_id</NAME>
<RETURNS>void 				</RETURNS>
AsSuggested *suggested, const gchar *cid
</FUNCTION>
<FUNCTION>
<NAME>as_suggested_is_valid</NAME>
<RETURNS>gboolean 			</RETURNS>
AsSuggested *suggested
</FUNCTION>
<STRUCT>
<NAME>AsSuggested</NAME>
</STRUCT>
<MACRO>
<NAME>AS_TYPE_VALIDATOR</NAME>
#define AS_TYPE_VALIDATOR (as_validator_get_type ())
</MACRO>
<STRUCT>
<NAME>AsValidatorClass</NAME>
struct _AsValidatorClass
{
	GObjectClass		parent_class;
	/*< private >*/
	void (*_as_reserved1)	(void);
	void (*_as_reserved2)	(void);
	void (*_as_reserved3)	(void);
	void (*_as_reserved4)	(void);
	void (*_as_reserved5)	(void);
	void (*_as_reserved6)	(void);
};
</STRUCT>
<FUNCTION>
<NAME>as_validator_new</NAME>
<RETURNS>AsValidator 	*</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>as_validator_clear_issues</NAME>
<RETURNS>void 		</RETURNS>
AsValidator *validator
</FUNCTION>
<FUNCTION>
<NAME>as_validator_validate_file</NAME>
<RETURNS>gboolean 	</RETURNS>
AsValidator *validator, GFile* metadata_file
</FUNCTION>
<FUNCTION>
<NAME>as_validator_validate_data</NAME>
<RETURNS>gboolean 	</RETURNS>
AsValidator *validator, const gchar *metadata
</FUNCTION>
<FUNCTION>
<NAME>as_validator_validate_tree</NAME>
<RETURNS>gboolean 	</RETURNS>
AsValidator *validator, const gchar *root_dir
</FUNCTION>
<FUNCTION>
<NAME>as_validator_get_issues</NAME>
<RETURNS>GList 		*</RETURNS>
AsValidator *validator
</FUNCTION>
<STRUCT>
<NAME>AsValidator</NAME>
</STRUCT>
<MACRO>
<NAME>AS_TYPE_TRANSLATION</NAME>
#define AS_TYPE_TRANSLATION (as_translation_get_type ())
</MACRO>
<STRUCT>
<NAME>AsTranslationClass</NAME>
struct _AsTranslationClass
{
	GObjectClass		parent_class;
	/*< private >*/
	void (*_as_reserved1)	(void);
	void (*_as_reserved2)	(void);
	void (*_as_reserved3)	(void);
	void (*_as_reserved4)	(void);
	void (*_as_reserved5)	(void);
	void (*_as_reserved6)	(void);
};
</STRUCT>
<ENUM>
<NAME>AsTranslationKind</NAME>
typedef enum {
	AS_TRANSLATION_KIND_UNKNOWN,
	AS_TRANSLATION_KIND_GETTEXT,
	AS_TRANSLATION_KIND_QT,
	/*< private >*/
	AS_TRANSLATION_KIND_LAST
} AsTranslationKind;
</ENUM>
<FUNCTION>
<NAME>as_translation_kind_to_string</NAME>
<RETURNS>const gchar 		*</RETURNS>
AsTranslationKind kind
</FUNCTION>
<FUNCTION>
<NAME>as_translation_kind_from_string</NAME>
<RETURNS>AsTranslationKind 	</RETURNS>
const gchar *kind_str
</FUNCTION>
<FUNCTION>
<NAME>as_translation_new</NAME>
<RETURNS>AsTranslation 		*</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>as_translation_get_kind</NAME>
<RETURNS>AsTranslationKind 	</RETURNS>
AsTranslation *tr
</FUNCTION>
<FUNCTION>
<NAME>as_translation_set_kind</NAME>
<RETURNS>void 			</RETURNS>
AsTranslation *tr, AsTranslationKind kind
</FUNCTION>
<FUNCTION>
<NAME>as_translation_get_id</NAME>
<RETURNS>const gchar 		*</RETURNS>
AsTranslation *tr
</FUNCTION>
<FUNCTION>
<NAME>as_translation_set_id</NAME>
<RETURNS>void 			</RETURNS>
AsTranslation *tr, const gchar *id
</FUNCTION>
<STRUCT>
<NAME>AsTranslation</NAME>
</STRUCT>
<MACRO>
<NAME>AS_TYPE_VALIDATOR_ISSUE</NAME>
#define AS_TYPE_VALIDATOR_ISSUE (as_validator_issue_get_type ())
</MACRO>
<STRUCT>
<NAME>AsValidatorIssueClass</NAME>
struct _AsValidatorIssueClass
{
	GObjectClass		parent_class;
	/*< private >*/
	void (*_as_reserved1)	(void);
	void (*_as_reserved2)	(void);
	void (*_as_reserved3)	(void);
	void (*_as_reserved4)	(void);
	void (*_as_reserved5)	(void);
	void (*_as_reserved6)	(void);
};
</STRUCT>
<ENUM>
<NAME>AsIssueImportance</NAME>
typedef enum {
	AS_ISSUE_IMPORTANCE_UNKNOWN,
	AS_ISSUE_IMPORTANCE_ERROR,
	AS_ISSUE_IMPORTANCE_WARNING,
	AS_ISSUE_IMPORTANCE_INFO,
	AS_ISSUE_IMPORTANCE_PEDANTIC,
	/*< private >*/
	AS_ISSUE_IMPORTANCE_LAST
} AsIssueImportance;
</ENUM>
<ENUM>
<NAME>AsIssueKind</NAME>
typedef enum {
	AS_ISSUE_KIND_UNKNOWN,
	AS_ISSUE_KIND_MARKUP_INVALID,
	AS_ISSUE_KIND_LEGACY,
	AS_ISSUE_KIND_TAG_DUPLICATED,
	AS_ISSUE_KIND_TAG_MISSING,
	AS_ISSUE_KIND_TAG_UNKNOWN,
	AS_ISSUE_KIND_TAG_NOT_ALLOWED,
	AS_ISSUE_KIND_PROPERTY_MISSING,
	AS_ISSUE_KIND_PROPERTY_INVALID,
	AS_ISSUE_KIND_VALUE_MISSING,
	AS_ISSUE_KIND_VALUE_WRONG,
	AS_ISSUE_KIND_VALUE_ISSUE,
	AS_ISSUE_KIND_FILE_MISSING,
	AS_ISSUE_KIND_WRONG_NAME,
	AS_ISSUE_KIND_READ_ERROR,
	/*< private >*/
	AS_ISSUE_KIND_LAST
} AsIssueKind;
</ENUM>
<FUNCTION>
<NAME>as_validator_issue_new</NAME>
<RETURNS>AsValidatorIssue 	*</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>as_validator_issue_get_kind</NAME>
<RETURNS>AsIssueKind 		</RETURNS>
AsValidatorIssue *issue
</FUNCTION>
<FUNCTION>
<NAME>as_validator_issue_set_kind</NAME>
<RETURNS>void 			</RETURNS>
AsValidatorIssue *issue, AsIssueKind kind
</FUNCTION>
<FUNCTION>
<NAME>as_validator_issue_get_importance</NAME>
<RETURNS>AsIssueImportance 	</RETURNS>
AsValidatorIssue *issue
</FUNCTION>
<FUNCTION>
<NAME>as_validator_issue_set_importance</NAME>
<RETURNS>void  			</RETURNS>
AsValidatorIssue *issue, AsIssueImportance importance
</FUNCTION>
<FUNCTION>
<NAME>as_validator_issue_get_message</NAME>
<RETURNS>const gchar 		*</RETURNS>
AsValidatorIssue *issue
</FUNCTION>
<FUNCTION>
<NAME>as_validator_issue_set_message</NAME>
<RETURNS>void 			</RETURNS>
AsValidatorIssue *issue, const gchar *message
</FUNCTION>
<FUNCTION>
<NAME>as_validator_issue_get_cid</NAME>
<RETURNS>const gchar 		*</RETURNS>
AsValidatorIssue *issue
</FUNCTION>
<FUNCTION>
<NAME>as_validator_issue_set_cid</NAME>
<RETURNS>void 			</RETURNS>
AsValidatorIssue *issue, const gchar *cid
</FUNCTION>
<FUNCTION>
<NAME>as_validator_issue_get_filename</NAME>
<RETURNS>const gchar 		*</RETURNS>
AsValidatorIssue *issue
</FUNCTION>
<FUNCTION>
<NAME>as_validator_issue_set_filename</NAME>
<RETURNS>void 			</RETURNS>
AsValidatorIssue *issue, const gchar *fname
</FUNCTION>
<FUNCTION>
<NAME>as_validator_issue_get_line</NAME>
<RETURNS>gint 			</RETURNS>
AsValidatorIssue *issue
</FUNCTION>
<FUNCTION>
<NAME>as_validator_issue_set_line</NAME>
<RETURNS>void 			</RETURNS>
AsValidatorIssue *issue, gint line
</FUNCTION>
<FUNCTION>
<NAME>as_validator_issue_get_location</NAME>
<RETURNS>gchar 			*</RETURNS>
AsValidatorIssue *issue
</FUNCTION>
<STRUCT>
<NAME>AsValidatorIssue</NAME>
</STRUCT>
<MACRO>
<NAME>AS_TYPE_CATEGORY</NAME>
#define AS_TYPE_CATEGORY (as_category_get_type ())
</MACRO>
<STRUCT>
<NAME>AsCategoryClass</NAME>
struct _AsCategoryClass
{
	GObjectClass parent_class;
	/*< private >*/
	void (*_as_reserved1)	(void);
	void (*_as_reserved2)	(void);
	void (*_as_reserved3)	(void);
	void (*_as_reserved4)	(void);
	void (*_as_reserved5)	(void);
	void (*_as_reserved6)	(void);
};
</STRUCT>
<FUNCTION>
<NAME>as_category_new</NAME>
<RETURNS>AsCategory 		*</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>as_category_complete</NAME>
<RETURNS>void 			</RETURNS>
AsCategory *cat
</FUNCTION>
<FUNCTION>
<NAME>as_category_get_directory</NAME>
<RETURNS>const gchar 		*</RETURNS>
AsCategory *cat
</FUNCTION>
<FUNCTION>
<NAME>as_category_set_directory</NAME>
<RETURNS>void 			</RETURNS>
AsCategory *cat, const gchar* value
</FUNCTION>
<FUNCTION>
<NAME>as_category_get_name</NAME>
<RETURNS>const gchar 		*</RETURNS>
AsCategory *cat
</FUNCTION>
<FUNCTION>
<NAME>as_category_set_name</NAME>
<RETURNS>void 			</RETURNS>
AsCategory *cat, const gchar *value
</FUNCTION>
<FUNCTION>
<NAME>as_category_get_summary</NAME>
<RETURNS>const gchar 		*</RETURNS>
AsCategory *cat
</FUNCTION>
<FUNCTION>
<NAME>as_category_set_summary</NAME>
<RETURNS>void 			</RETURNS>
AsCategory *cat, const gchar *value
</FUNCTION>
<FUNCTION>
<NAME>as_category_get_icon</NAME>
<RETURNS>const gchar 		*</RETURNS>
AsCategory *cat
</FUNCTION>
<FUNCTION>
<NAME>as_category_set_icon</NAME>
<RETURNS>void 			</RETURNS>
AsCategory *cat, const gchar* value
</FUNCTION>
<FUNCTION>
<NAME>as_category_has_subcategory</NAME>
<RETURNS>gboolean 		</RETURNS>
AsCategory *cat
</FUNCTION>
<FUNCTION>
<NAME>as_category_add_subcategory</NAME>
<RETURNS>void 			</RETURNS>
AsCategory *cat, AsCategory *subcat
</FUNCTION>
<FUNCTION>
<NAME>as_category_remove_subcategory</NAME>
<RETURNS>void 			</RETURNS>
AsCategory *cat, AsCategory *subcat
</FUNCTION>
<FUNCTION>
<NAME>as_category_get_included</NAME>
<RETURNS>GList 			*</RETURNS>
AsCategory *cat
</FUNCTION>
<FUNCTION>
<NAME>as_category_get_excluded</NAME>
<RETURNS>GList 			*</RETURNS>
AsCategory *cat
</FUNCTION>
<FUNCTION>
<NAME>as_category_get_subcategories</NAME>
<RETURNS>GList 			*</RETURNS>
AsCategory *cat
</FUNCTION>
<FUNCTION>
<NAME>as_category_get_level</NAME>
<RETURNS>gint 			</RETURNS>
AsCategory *cat
</FUNCTION>
<FUNCTION>
<NAME>as_category_set_level</NAME>
<RETURNS>void 			</RETURNS>
AsCategory *cat, gint value
</FUNCTION>
<STRUCT>
<NAME>AsCategory</NAME>
</STRUCT>
<MACRO>
<NAME>AS_TYPE_DISTRO_DETAILS</NAME>
#define AS_TYPE_DISTRO_DETAILS (as_distro_details_get_type ())
</MACRO>
<STRUCT>
<NAME>AsDistroDetailsClass</NAME>
struct _AsDistroDetailsClass
{
	GObjectClass parent_class;
	/*< private >*/
	void (*_as_reserved1)	(void);
	void (*_as_reserved2)	(void);
	void (*_as_reserved3)	(void);
	void (*_as_reserved4)	(void);
	void (*_as_reserved5)	(void);
	void (*_as_reserved6)	(void);
};
</STRUCT>
<FUNCTION>
<NAME>as_distro_details_new</NAME>
<RETURNS>AsDistroDetails 		*</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>as_distro_details_get_id</NAME>
<RETURNS>const gchar 		*</RETURNS>
AsDistroDetails *distro
</FUNCTION>
<FUNCTION>
<NAME>as_distro_details_get_name</NAME>
<RETURNS>const gchar 		*</RETURNS>
AsDistroDetails *distro
</FUNCTION>
<FUNCTION>
<NAME>as_distro_details_get_version</NAME>
<RETURNS>const gchar 		*</RETURNS>
AsDistroDetails *distro
</FUNCTION>
<FUNCTION>
<NAME>as_distro_details_get_str</NAME>
<RETURNS>gchar 			*</RETURNS>
AsDistroDetails *distro, const gchar *key
</FUNCTION>
<FUNCTION>
<NAME>as_distro_details_get_bool</NAME>
<RETURNS>gboolean 		</RETURNS>
AsDistroDetails *distro, const gchar *key
</FUNCTION>
<FUNCTION>
<NAME>as_get_icon_repository_paths</NAME>
<RETURNS>gchar 			**</RETURNS>
void
</FUNCTION>
<STRUCT>
<NAME>AsDistroDetails</NAME>
</STRUCT>
<MACRO>
<NAME>AS_TYPE_SCREENSHOT</NAME>
#define AS_TYPE_SCREENSHOT (as_screenshot_get_type ())
</MACRO>
<STRUCT>
<NAME>AsScreenshotClass</NAME>
struct _AsScreenshotClass
{
	GObjectClass		parent_class;
	/*< private >*/
	void (*_as_reserved1)	(void);
	void (*_as_reserved2)	(void);
	void (*_as_reserved3)	(void);
	void (*_as_reserved4)	(void);
	void (*_as_reserved5)	(void);
	void (*_as_reserved6)	(void);
};
</STRUCT>
<ENUM>
<NAME>AsScreenshotKind</NAME>
typedef enum {
	AS_SCREENSHOT_KIND_UNKNOWN,
	AS_SCREENSHOT_KIND_DEFAULT,
	AS_SCREENSHOT_KIND_EXTRA,
	/*< private >*/
	AS_SCREENSHOT_KIND_LAST
} AsScreenshotKind;
</ENUM>
<FUNCTION>
<NAME>as_screenshot_kind_from_string</NAME>
<RETURNS>AsScreenshotKind 		</RETURNS>
const gchar *kind
</FUNCTION>
<FUNCTION>
<NAME>as_screenshot_kind_to_string</NAME>
<RETURNS>const gchar 			*</RETURNS>
AsScreenshotKind kind
</FUNCTION>
<FUNCTION>
<NAME>as_screenshot_is_valid</NAME>
<RETURNS>gboolean 			</RETURNS>
AsScreenshot *screenshot
</FUNCTION>
<FUNCTION>
<NAME>as_screenshot_new</NAME>
<RETURNS>AsScreenshot 			*</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>as_screenshot_get_kind</NAME>
<RETURNS>AsScreenshotKind 		</RETURNS>
AsScreenshot *screenshot
</FUNCTION>
<FUNCTION>
<NAME>as_screenshot_set_kind</NAME>
<RETURNS>void 		 		</RETURNS>
AsScreenshot *screenshot, AsScreenshotKind kind
</FUNCTION>
<FUNCTION>
<NAME>as_screenshot_get_caption</NAME>
<RETURNS>const gchar 			*</RETURNS>
AsScreenshot *screenshot
</FUNCTION>
<FUNCTION>
<NAME>as_screenshot_set_caption</NAME>
<RETURNS>void 				</RETURNS>
AsScreenshot *screenshot, const gchar *caption, const gchar *locale
</FUNCTION>
<FUNCTION>
<NAME>as_screenshot_get_images</NAME>
<RETURNS>GPtrArray 			*</RETURNS>
AsScreenshot *screenshot
</FUNCTION>
<FUNCTION>
<NAME>as_screenshot_add_image</NAME>
<RETURNS>void 				</RETURNS>
AsScreenshot *screenshot, AsImage *image
</FUNCTION>
<FUNCTION>
<NAME>as_screenshot_get_active_locale</NAME>
<RETURNS>gchar 				*</RETURNS>
AsScreenshot *screenshot
</FUNCTION>
<FUNCTION>
<NAME>as_screenshot_set_active_locale</NAME>
<RETURNS>void 				</RETURNS>
AsScreenshot *screenshot, const gchar *locale
</FUNCTION>
<FUNCTION>
<NAME>as_screenshot_get_images_localized</NAME>
<RETURNS>GPtrArray 			*</RETURNS>
AsScreenshot *screenshot
</FUNCTION>
<STRUCT>
<NAME>AsScreenshot</NAME>
</STRUCT>
<MACRO>
<NAME>AS_TYPE_DATABASE</NAME>
#define AS_TYPE_DATABASE (as_database_get_type ())
</MACRO>
<STRUCT>
<NAME>AsDatabaseClass</NAME>
struct _AsDatabaseClass
{
	GObjectClass parent_class;
	/*< private >*/
	void (*_as_reserved1)	(void);
	void (*_as_reserved2)	(void);
	void (*_as_reserved3)	(void);
	void (*_as_reserved4)	(void);
	void (*_as_reserved5)	(void);
	void (*_as_reserved6)	(void);
};
</STRUCT>
<ENUM>
<NAME>AsDatabaseError</NAME>
<DEPRECATED/>
typedef enum {
	AS_DATABASE_ERROR_FAILED,
	AS_DATABASE_ERROR_MISSING,
	AS_DATABASE_ERROR_CLOSED,
	AS_DATABASE_ERROR_TERM_INVALID,
	/*< private >*/
	AS_DATABASE_ERROR_LAST
} AsDatabaseError;
</ENUM>
<MACRO>
<NAME>AS_DATABASE_ERROR</NAME>
#define	AS_DATABASE_ERROR	as_database_error_quark ()
</MACRO>
<FUNCTION>
<NAME>as_database_new</NAME>
<DEPRECATED/>
<RETURNS>AsDatabase 		*</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>as_database_error_quark</NAME>
<RETURNS>GQuark 			</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>as_database_open</NAME>
<DEPRECATED/>
<RETURNS>gboolean 		</RETURNS>
AsDatabase *db, GError **error
</FUNCTION>
<FUNCTION>
<NAME>as_database_get_location</NAME>
<DEPRECATED/>
<RETURNS>const gchar 		*</RETURNS>
AsDatabase *db
</FUNCTION>
<FUNCTION>
<NAME>as_database_set_location</NAME>
<DEPRECATED/>
<RETURNS>void 			</RETURNS>
AsDatabase *db, const gchar *dir
</FUNCTION>
<FUNCTION>
<NAME>as_database_find_components</NAME>
<DEPRECATED/>
<RETURNS>GPtrArray 		*</RETURNS>
AsDatabase *db, const gchar *term, const gchar *cats_str, GError **error
</FUNCTION>
<FUNCTION>
<NAME>as_database_get_all_components</NAME>
<DEPRECATED/>
<RETURNS>GPtrArray 		*</RETURNS>
AsDatabase *db, GError **error
</FUNCTION>
<FUNCTION>
<NAME>as_database_get_component_by_id</NAME>
<DEPRECATED/>
<RETURNS>AsComponent 		*</RETURNS>
AsDatabase *db, const gchar *cid, GError **error
</FUNCTION>
<FUNCTION>
<NAME>as_database_get_components_by_provided_item</NAME>
<DEPRECATED/>
<RETURNS>GPtrArray 		*</RETURNS>
AsDatabase *db, AsProvidedKind kind, const gchar *item, GError **error
</FUNCTION>
<FUNCTION>
<NAME>as_database_get_components_by_kind</NAME>
<DEPRECATED/>
<RETURNS>GPtrArray 		*</RETURNS>
AsDatabase *db, AsComponentKind kind, GError **error
</FUNCTION>
<STRUCT>
<NAME>AsDatabase</NAME>
</STRUCT>
<MACRO>
<NAME>AS_TYPE_COMPONENT</NAME>
#define AS_TYPE_COMPONENT (as_component_get_type ())
</MACRO>
<STRUCT>
<NAME>AsComponentClass</NAME>
struct _AsComponentClass
{
	GObjectClass		parent_class;
	/*< private >*/
	void (*_as_reserved1)	(void);
	void (*_as_reserved2)	(void);
	void (*_as_reserved3)	(void);
	void (*_as_reserved4)	(void);
	void (*_as_reserved5)	(void);
	void (*_as_reserved6)	(void);
};
</STRUCT>
<ENUM>
<NAME>AsComponentKind</NAME>
typedef enum  {
	AS_COMPONENT_KIND_UNKNOWN,
	AS_COMPONENT_KIND_GENERIC,
	AS_COMPONENT_KIND_DESKTOP_APP,
	AS_COMPONENT_KIND_FONT,
	AS_COMPONENT_KIND_CODEC,
	AS_COMPONENT_KIND_INPUTMETHOD,
	AS_COMPONENT_KIND_ADDON,
	AS_COMPONENT_KIND_FIRMWARE,
	AS_COMPONENT_KIND_CONSOLE_APP,
	/*< private >*/
	AS_COMPONENT_KIND_LAST
} AsComponentKind;
</ENUM>
<MACRO>
<NAME>AS_TYPE_COMPONENT_KIND</NAME>
#define AS_TYPE_COMPONENT_KIND (as_component_kind_get_type ())
</MACRO>
<FUNCTION>
<NAME>as_component_kind_get_type</NAME>
<RETURNS>GType 			</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>as_component_kind_to_string</NAME>
<RETURNS>const gchar 		*</RETURNS>
AsComponentKind kind
</FUNCTION>
<FUNCTION>
<NAME>as_component_kind_from_string</NAME>
<RETURNS>AsComponentKind 		</RETURNS>
const gchar *kind_str
</FUNCTION>
<ENUM>
<NAME>AsMergeKind</NAME>
typedef enum  {
	AS_MERGE_KIND_NONE,
	AS_MERGE_KIND_REPLACE,
	AS_MERGE_KIND_APPEND,
	/*< private >*/
	AS_MERGE_KIND_LAST
} AsMergeKind;
</ENUM>
<FUNCTION>
<NAME>as_merge_kind_to_string</NAME>
<RETURNS>const gchar 		*</RETURNS>
AsMergeKind kind
</FUNCTION>
<FUNCTION>
<NAME>as_merge_kind_from_string</NAME>
<RETURNS>AsMergeKind 		</RETURNS>
const gchar *kind_str
</FUNCTION>
<FUNCTION>
<NAME>as_component_new</NAME>
<RETURNS>AsComponent 		*</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>as_component_is_valid</NAME>
<RETURNS>gboolean 		</RETURNS>
AsComponent *cpt
</FUNCTION>
<FUNCTION>
<NAME>as_component_to_string</NAME>
<RETURNS>gchar 			*</RETURNS>
AsComponent *cpt
</FUNCTION>
<FUNCTION>
<NAME>as_component_get_active_locale</NAME>
<RETURNS>gchar 			*</RETURNS>
AsComponent *cpt
</FUNCTION>
<FUNCTION>
<NAME>as_component_set_active_locale</NAME>
<RETURNS>void 			</RETURNS>
AsComponent *cpt, const gchar *locale
</FUNCTION>
<FUNCTION>
<NAME>as_component_get_kind</NAME>
<RETURNS>AsComponentKind 		</RETURNS>
AsComponent *cpt
</FUNCTION>
<FUNCTION>
<NAME>as_component_set_kind</NAME>
<RETURNS>void 			</RETURNS>
AsComponent *cpt, AsComponentKind value
</FUNCTION>
<FUNCTION>
<NAME>as_component_get_id</NAME>
<RETURNS>const gchar 		*</RETURNS>
AsComponent *cpt
</FUNCTION>
<FUNCTION>
<NAME>as_component_set_id</NAME>
<RETURNS>void 			</RETURNS>
AsComponent *cpt, const gchar *value
</FUNCTION>
<FUNCTION>
<NAME>as_component_get_desktop_id</NAME>
<RETURNS>const gchar 		*</RETURNS>
AsComponent *cpt
</FUNCTION>
<FUNCTION>
<NAME>as_component_get_origin</NAME>
<RETURNS>const gchar 		*</RETURNS>
AsComponent *cpt
</FUNCTION>
<FUNCTION>
<NAME>as_component_set_origin</NAME>
<RETURNS>void 			</RETURNS>
AsComponent *cpt, const gchar *origin
</FUNCTION>
<FUNCTION>
<NAME>as_component_get_pkgnames</NAME>
<RETURNS>gchar 			**</RETURNS>
AsComponent *cpt
</FUNCTION>
<FUNCTION>
<NAME>as_component_set_pkgnames</NAME>
<RETURNS>void 			</RETURNS>
AsComponent *cpt, gchar **value
</FUNCTION>
<FUNCTION>
<NAME>as_component_get_source_pkgname</NAME>
<RETURNS>const gchar 		*</RETURNS>
AsComponent *cpt
</FUNCTION>
<FUNCTION>
<NAME>as_component_set_source_pkgname</NAME>
<RETURNS>void 			</RETURNS>
AsComponent *cpt, const gchar* spkgname
</FUNCTION>
<FUNCTION>
<NAME>as_component_get_name</NAME>
<RETURNS>const gchar 		*</RETURNS>
AsComponent *cpt
</FUNCTION>
<FUNCTION>
<NAME>as_component_set_name</NAME>
<RETURNS>void 			</RETURNS>
AsComponent *cpt, const gchar *value, const gchar *locale
</FUNCTION>
<FUNCTION>
<NAME>as_component_get_summary</NAME>
<RETURNS>const gchar 		*</RETURNS>
AsComponent *cpt
</FUNCTION>
<FUNCTION>
<NAME>as_component_set_summary</NAME>
<RETURNS>void 			</RETURNS>
AsComponent *cpt, const gchar *value, const gchar *locale
</FUNCTION>
<FUNCTION>
<NAME>as_component_get_description</NAME>
<RETURNS>const gchar 		*</RETURNS>
AsComponent *cpt
</FUNCTION>
<FUNCTION>
<NAME>as_component_set_description</NAME>
<RETURNS>void 			</RETURNS>
AsComponent *cpt, const gchar *value, const gchar *locale
</FUNCTION>
<FUNCTION>
<NAME>as_component_get_metadata_license</NAME>
<RETURNS>const gchar 		*</RETURNS>
AsComponent *cpt
</FUNCTION>
<FUNCTION>
<NAME>as_component_set_metadata_license</NAME>
<RETURNS>void 			</RETURNS>
AsComponent *cpt, const gchar *value
</FUNCTION>
<FUNCTION>
<NAME>as_component_get_project_license</NAME>
<RETURNS>const gchar 		*</RETURNS>
AsComponent *cpt
</FUNCTION>
<FUNCTION>
<NAME>as_component_set_project_license</NAME>
<RETURNS>void 			</RETURNS>
AsComponent *cpt, const gchar *value
</FUNCTION>
<FUNCTION>
<NAME>as_component_get_project_group</NAME>
<RETURNS>const gchar 		*</RETURNS>
AsComponent *cpt
</FUNCTION>
<FUNCTION>
<NAME>as_component_set_project_group</NAME>
<RETURNS>void 			</RETURNS>
AsComponent *cpt, const gchar *value
</FUNCTION>
<FUNCTION>
<NAME>as_component_get_developer_name</NAME>
<RETURNS>const gchar 		*</RETURNS>
AsComponent *cpt
</FUNCTION>
<FUNCTION>
<NAME>as_component_set_developer_name</NAME>
<RETURNS>void 			</RETURNS>
AsComponent *cpt, const gchar *value, const gchar *locale
</FUNCTION>
<FUNCTION>
<NAME>as_component_get_compulsory_for_desktops</NAME>
<RETURNS>gchar 			**</RETURNS>
AsComponent *cpt
</FUNCTION>
<FUNCTION>
<NAME>as_component_set_compulsory_for_desktops</NAME>
<RETURNS>void 			</RETURNS>
AsComponent *cpt, gchar **value
</FUNCTION>
<FUNCTION>
<NAME>as_component_is_compulsory_for_desktop</NAME>
<RETURNS>gboolean 		</RETURNS>
AsComponent *cpt, const gchar *desktop
</FUNCTION>
<FUNCTION>
<NAME>as_component_get_categories</NAME>
<RETURNS>gchar 			**</RETURNS>
AsComponent *cpt
</FUNCTION>
<FUNCTION>
<NAME>as_component_set_categories</NAME>
<RETURNS>void 			</RETURNS>
AsComponent *cpt, gchar **value
</FUNCTION>
<FUNCTION>
<NAME>as_component_has_category</NAME>
<RETURNS>gboolean 		</RETURNS>
AsComponent *cpt, const gchar *category
</FUNCTION>
<FUNCTION>
<NAME>as_component_get_screenshots</NAME>
<RETURNS>GPtrArray 		*</RETURNS>
AsComponent *cpt
</FUNCTION>
<FUNCTION>
<NAME>as_component_add_screenshot</NAME>
<RETURNS>void 			</RETURNS>
AsComponent *cpt, AsScreenshot *sshot
</FUNCTION>
<FUNCTION>
<NAME>as_component_get_keywords</NAME>
<RETURNS>gchar 			**</RETURNS>
AsComponent *cpt
</FUNCTION>
<FUNCTION>
<NAME>as_component_set_keywords</NAME>
<RETURNS>void 			</RETURNS>
AsComponent *cpt, gchar **value, const gchar *locale
</FUNCTION>
<FUNCTION>
<NAME>as_component_get_icons</NAME>
<RETURNS>GPtrArray 		*</RETURNS>
AsComponent *cpt
</FUNCTION>
<FUNCTION>
<NAME>as_component_get_icon_by_size</NAME>
<RETURNS>AsIcon 			*</RETURNS>
AsComponent *cpt, guint width, guint height
</FUNCTION>
<FUNCTION>
<NAME>as_component_add_icon</NAME>
<RETURNS>void 			</RETURNS>
AsComponent *cpt, AsIcon *icon
</FUNCTION>
<FUNCTION>
<NAME>as_component_add_provided</NAME>
<RETURNS>void 			</RETURNS>
AsComponent *cpt, AsProvided *prov
</FUNCTION>
<FUNCTION>
<NAME>as_component_get_provided_for_kind</NAME>
<RETURNS>AsProvided 		*</RETURNS>
AsComponent *cpt, AsProvidedKind kind
</FUNCTION>
<FUNCTION>
<NAME>as_component_get_provided</NAME>
<RETURNS>GList 			*</RETURNS>
AsComponent *cpt
</FUNCTION>
<FUNCTION>
<NAME>as_component_get_url</NAME>
<RETURNS>const gchar 		*</RETURNS>
AsComponent *cpt, AsUrlKind url_kind
</FUNCTION>
<FUNCTION>
<NAME>as_component_add_url</NAME>
<RETURNS>void 			</RETURNS>
AsComponent *cpt, AsUrlKind url_kind, const gchar *url
</FUNCTION>
<FUNCTION>
<NAME>as_component_get_releases</NAME>
<RETURNS>GPtrArray 		*</RETURNS>
AsComponent *cpt
</FUNCTION>
<FUNCTION>
<NAME>as_component_add_release</NAME>
<RETURNS>void 			</RETURNS>
AsComponent *cpt, AsRelease* release
</FUNCTION>
<FUNCTION>
<NAME>as_component_get_extends</NAME>
<RETURNS>GPtrArray 		*</RETURNS>
AsComponent *cpt
</FUNCTION>
<FUNCTION>
<NAME>as_component_add_extends</NAME>
<RETURNS>void 			</RETURNS>
AsComponent *cpt, const gchar *cpt_id
</FUNCTION>
<FUNCTION>
<NAME>as_component_get_extensions</NAME>
<RETURNS>GPtrArray 		*</RETURNS>
AsComponent *cpt
</FUNCTION>
<FUNCTION>
<NAME>as_component_add_extension</NAME>
<RETURNS>void 			</RETURNS>
AsComponent *cpt, const gchar *cpt_id
</FUNCTION>
<FUNCTION>
<NAME>as_component_get_languages</NAME>
<RETURNS>GList 			*</RETURNS>
AsComponent *cpt
</FUNCTION>
<FUNCTION>
<NAME>as_component_get_language</NAME>
<RETURNS>gint 			</RETURNS>
AsComponent *cpt, const gchar *locale
</FUNCTION>
<FUNCTION>
<NAME>as_component_add_language</NAME>
<RETURNS>void 			</RETURNS>
AsComponent *cpt, const gchar *locale, gint percentage
</FUNCTION>
<FUNCTION>
<NAME>as_component_get_translations</NAME>
<RETURNS>GPtrArray 		*</RETURNS>
AsComponent *cpt
</FUNCTION>
<FUNCTION>
<NAME>as_component_add_translation</NAME>
<RETURNS>void 			</RETURNS>
AsComponent *cpt, AsTranslation *tr
</FUNCTION>
<FUNCTION>
<NAME>as_component_has_bundle</NAME>
<RETURNS>gboolean 		</RETURNS>
AsComponent *cpt
</FUNCTION>
<FUNCTION>
<NAME>as_component_get_bundle_id</NAME>
<RETURNS>const gchar 		*</RETURNS>
AsComponent *cpt, AsBundleKind bundle_kind
</FUNCTION>
<FUNCTION>
<NAME>as_component_add_bundle_id</NAME>
<RETURNS>void 			</RETURNS>
AsComponent *cpt, AsBundleKind bundle_kind, const gchar *id
</FUNCTION>
<FUNCTION>
<NAME>as_component_get_suggested</NAME>
<RETURNS>GPtrArray 		*</RETURNS>
AsComponent *cpt
</FUNCTION>
<FUNCTION>
<NAME>as_component_add_suggested</NAME>
<RETURNS>void 			</RETURNS>
AsComponent *cpt, AsSuggested *suggested
</FUNCTION>
<FUNCTION>
<NAME>as_component_get_search_tokens</NAME>
<RETURNS>GPtrArray 		*</RETURNS>
AsComponent *cpt
</FUNCTION>
<FUNCTION>
<NAME>as_component_search_matches</NAME>
<RETURNS>guint 			</RETURNS>
AsComponent *cpt, const gchar *term
</FUNCTION>
<FUNCTION>
<NAME>as_component_search_matches_all</NAME>
<RETURNS>guint 			</RETURNS>
AsComponent *cpt, gchar **terms
</FUNCTION>
<FUNCTION>
<NAME>as_component_get_merge_kind</NAME>
<RETURNS>AsMergeKind 		</RETURNS>
AsComponent *cpt
</FUNCTION>
<FUNCTION>
<NAME>as_component_set_merge_kind</NAME>
<RETURNS>void 			</RETURNS>
AsComponent *cpt, AsMergeKind kind
</FUNCTION>
<STRUCT>
<NAME>AsComponent</NAME>
</STRUCT>
<MACRO>
<NAME>AS_TYPE_STEMMER</NAME>
#define AS_TYPE_STEMMER	(as_stemmer_get_type ())
</MACRO>
<FUNCTION>
<NAME>as_stemmer_get</NAME>
<RETURNS>AsStemmer 		*</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>as_stemmer_reload</NAME>
<RETURNS>void 			</RETURNS>
AsStemmer *stemmer, const gchar *lang
</FUNCTION>
<FUNCTION>
<NAME>as_stemmer_stem</NAME>
<RETURNS>gchar 			*</RETURNS>
AsStemmer *stemmer, const gchar *term
</FUNCTION>
<STRUCT>
<NAME>AsStemmer</NAME>
</STRUCT>
<MACRO>
<NAME>AS_TYPE_ICON</NAME>
#define AS_TYPE_ICON (as_icon_get_type ())
</MACRO>
<STRUCT>
<NAME>AsIconClass</NAME>
struct _AsIconClass
{
	GObjectClass		parent_class;
	/*< private >*/
	void (*_as_reserved1)	(void);
	void (*_as_reserved2)	(void);
	void (*_as_reserved3)	(void);
	void (*_as_reserved4)	(void);
	void (*_as_reserved5)	(void);
	void (*_as_reserved6)	(void);
};
</STRUCT>
<ENUM>
<NAME>AsIconKind</NAME>
typedef enum  {
	AS_ICON_KIND_UNKNOWN,
	AS_ICON_KIND_CACHED,
	AS_ICON_KIND_STOCK,
	AS_ICON_KIND_LOCAL,
	AS_ICON_KIND_REMOTE,
	/*< private >*/
	AS_ICON_KIND_LAST
} AsIconKind;
</ENUM>
<FUNCTION>
<NAME>as_icon_kind_from_string</NAME>
<RETURNS>AsIconKind 	</RETURNS>
const gchar *kind_str
</FUNCTION>
<FUNCTION>
<NAME>as_icon_kind_to_string</NAME>
<RETURNS>const gchar 	*</RETURNS>
AsIconKind kind
</FUNCTION>
<FUNCTION>
<NAME>as_icon_new</NAME>
<RETURNS>AsIcon 		*</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>as_icon_get_kind</NAME>
<RETURNS>AsIconKind 	 </RETURNS>
AsIcon *icon
</FUNCTION>
<FUNCTION>
<NAME>as_icon_set_kind</NAME>
<RETURNS>void 		 </RETURNS>
AsIcon *icon, AsIconKind kind
</FUNCTION>
<FUNCTION>
<NAME>as_icon_get_name</NAME>
<RETURNS>const gchar 	*</RETURNS>
AsIcon *icon
</FUNCTION>
<FUNCTION>
<NAME>as_icon_set_name</NAME>
<RETURNS>void 		 </RETURNS>
AsIcon *icon, const gchar *name
</FUNCTION>
<FUNCTION>
<NAME>as_icon_get_url</NAME>
<RETURNS>const gchar 	*</RETURNS>
AsIcon *icon
</FUNCTION>
<FUNCTION>
<NAME>as_icon_set_url</NAME>
<RETURNS>void 		 </RETURNS>
AsIcon *icon, const gchar *url
</FUNCTION>
<FUNCTION>
<NAME>as_icon_get_filename</NAME>
<RETURNS>const gchar 	*</RETURNS>
AsIcon *icon
</FUNCTION>
<FUNCTION>
<NAME>as_icon_set_filename</NAME>
<RETURNS>void 		 </RETURNS>
AsIcon *icon, const gchar *filename
</FUNCTION>
<FUNCTION>
<NAME>as_icon_get_width</NAME>
<RETURNS>guint 		 </RETURNS>
AsIcon *icon
</FUNCTION>
<FUNCTION>
<NAME>as_icon_set_width</NAME>
<RETURNS>void 		 </RETURNS>
AsIcon *icon, guint width
</FUNCTION>
<FUNCTION>
<NAME>as_icon_get_height</NAME>
<RETURNS>guint 		 </RETURNS>
AsIcon *icon
</FUNCTION>
<FUNCTION>
<NAME>as_icon_set_height</NAME>
<RETURNS>void 		 </RETURNS>
AsIcon *icon, guint height
</FUNCTION>
<STRUCT>
<NAME>AsIcon</NAME>
</STRUCT>
<MACRO>
<NAME>AS_TYPE_METADATA</NAME>
#define AS_TYPE_METADATA (as_metadata_get_type ())
</MACRO>
<STRUCT>
<NAME>AsMetadataClass</NAME>
struct _AsMetadataClass
{
	GObjectClass		parent_class;
	/*< private >*/
	void (*_as_reserved1)	(void);
	void (*_as_reserved2)	(void);
	void (*_as_reserved3)	(void);
	void (*_as_reserved4)	(void);
	void (*_as_reserved5)	(void);
	void (*_as_reserved6)	(void);
};
</STRUCT>
<ENUM>
<NAME>AsParserMode</NAME>
typedef enum {
	AS_PARSER_MODE_UPSTREAM,
	AS_PARSER_MODE_DISTRO,
	/*< private >*/
	AS_PARSER_MODE_LAST
} AsParserMode;
</ENUM>
<ENUM>
<NAME>AsMetadataError</NAME>
typedef enum {
	AS_METADATA_ERROR_FAILED,
	AS_METADATA_ERROR_PARSE,
	AS_METADATA_ERROR_UNEXPECTED_FORMAT_KIND,
	AS_METADATA_ERROR_NO_COMPONENT,
	/*< private >*/
	AS_METADATA_ERROR_LAST
} AsMetadataError;
</ENUM>
<MACRO>
<NAME>AS_METADATA_ERROR</NAME>
#define	AS_METADATA_ERROR	as_metadata_error_quark ()
</MACRO>
<FUNCTION>
<NAME>as_metadata_new</NAME>
<RETURNS>AsMetadata 		*</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>as_metadata_error_quark</NAME>
<RETURNS>GQuark 			</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>as_metadata_parse_file</NAME>
<RETURNS>void 			</RETURNS>
AsMetadata *metad, GFile *file, GError **error
</FUNCTION>
<FUNCTION>
<NAME>as_metadata_parse_xml</NAME>
<RETURNS>void 			</RETURNS>
AsMetadata *metad, const gchar *data, GError **error
</FUNCTION>
<FUNCTION>
<NAME>as_metadata_parse_yaml</NAME>
<RETURNS>void 			</RETURNS>
AsMetadata *metad, const gchar *data, GError **error
</FUNCTION>
<FUNCTION>
<NAME>as_metadata_get_component</NAME>
<RETURNS>AsComponent 		*</RETURNS>
AsMetadata *metad
</FUNCTION>
<FUNCTION>
<NAME>as_metadata_get_components</NAME>
<RETURNS>GPtrArray 		*</RETURNS>
AsMetadata *metad
</FUNCTION>
<FUNCTION>
<NAME>as_metadata_clear_components</NAME>
<RETURNS>void 			</RETURNS>
AsMetadata *metad
</FUNCTION>
<FUNCTION>
<NAME>as_metadata_add_component</NAME>
<RETURNS>void 			</RETURNS>
AsMetadata *metad, AsComponent *cpt
</FUNCTION>
<FUNCTION>
<NAME>as_metadata_component_to_upstream_xml</NAME>
<RETURNS>gchar 			*</RETURNS>
AsMetadata *metad
</FUNCTION>
<FUNCTION>
<NAME>as_metadata_save_upstream_xml</NAME>
<RETURNS>void 			</RETURNS>
AsMetadata *metad, const gchar *fname, GError **error
</FUNCTION>
<FUNCTION>
<NAME>as_metadata_components_to_distro_xml</NAME>
<RETURNS>gchar 			*</RETURNS>
AsMetadata *metad
</FUNCTION>
<FUNCTION>
<NAME>as_metadata_save_distro_xml</NAME>
<RETURNS>void 			</RETURNS>
AsMetadata *metad, const gchar *fname, GError **error
</FUNCTION>
<FUNCTION>
<NAME>as_metadata_components_to_distro_yaml</NAME>
<RETURNS>gchar 			*</RETURNS>
AsMetadata *metad
</FUNCTION>
<FUNCTION>
<NAME>as_metadata_save_distro_yaml</NAME>
<RETURNS>void 			</RETURNS>
AsMetadata *metad, const gchar *fname, GError **error
</FUNCTION>
<FUNCTION>
<NAME>as_metadata_set_locale</NAME>
<RETURNS>void 			</RETURNS>
AsMetadata *metad, const gchar *locale
</FUNCTION>
<FUNCTION>
<NAME>as_metadata_get_locale</NAME>
<RETURNS>const gchar 		*</RETURNS>
AsMetadata *metad
</FUNCTION>
<FUNCTION>
<NAME>as_metadata_get_origin</NAME>
<RETURNS>const gchar 		*</RETURNS>
AsMetadata *metad
</FUNCTION>
<FUNCTION>
<NAME>as_metadata_set_origin</NAME>
<RETURNS>void 			</RETURNS>
AsMetadata *metad, const gchar *origin
</FUNCTION>
<FUNCTION>
<NAME>as_metadata_get_update_existing</NAME>
<RETURNS>gboolean 		</RETURNS>
AsMetadata *metad
</FUNCTION>
<FUNCTION>
<NAME>as_metadata_set_update_existing</NAME>
<RETURNS>void 			</RETURNS>
AsMetadata *metad, gboolean update
</FUNCTION>
<FUNCTION>
<NAME>as_metadata_get_write_header</NAME>
<RETURNS>gboolean 		</RETURNS>
AsMetadata *metad
</FUNCTION>
<FUNCTION>
<NAME>as_metadata_set_write_header</NAME>
<RETURNS>void 			</RETURNS>
AsMetadata *metad, gboolean wheader
</FUNCTION>
<FUNCTION>
<NAME>as_metadata_set_parser_mode</NAME>
<RETURNS>void 			</RETURNS>
AsMetadata *metad, AsParserMode mode
</FUNCTION>
<FUNCTION>
<NAME>as_metadata_get_parser_mode</NAME>
<RETURNS>AsParserMode 		</RETURNS>
AsMetadata *metad
</FUNCTION>
<FUNCTION>
<NAME>as_metadata_get_architecture</NAME>
<RETURNS>const gchar 		*</RETURNS>
AsMetadata *metad
</FUNCTION>
<FUNCTION>
<NAME>as_metadata_set_architecture</NAME>
<RETURNS>void 			</RETURNS>
AsMetadata *metad, const gchar *arch
</FUNCTION>
<STRUCT>
<NAME>AsMetadata</NAME>
</STRUCT>
<MACRO>
<NAME>AS_TYPE_MENU_PARSER</NAME>
#define AS_TYPE_MENU_PARSER (as_menu_parser_get_type ())
</MACRO>
<STRUCT>
<NAME>AsMenuParserClass</NAME>
struct _AsMenuParserClass
{
	GObjectClass parent_class;
	/*< private >*/
	void (*_as_reserved1)	(void);
	void (*_as_reserved2)	(void);
	void (*_as_reserved3)	(void);
	void (*_as_reserved4)	(void);
	void (*_as_reserved5)	(void);
	void (*_as_reserved6)	(void);
};
</STRUCT>
<FUNCTION>
<NAME>as_menu_parser_new</NAME>
<RETURNS>AsMenuParser 		*</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>as_menu_parser_new_from_file</NAME>
<RETURNS>AsMenuParser 		*</RETURNS>
const gchar *menu_file
</FUNCTION>
<FUNCTION>
<NAME>as_menu_parser_parse</NAME>
<RETURNS>GList 			*</RETURNS>
AsMenuParser *mp
</FUNCTION>
<FUNCTION>
<NAME>as_menu_parser_get_update_category_data</NAME>
<RETURNS>gboolean 		</RETURNS>
AsMenuParser *mp
</FUNCTION>
<FUNCTION>
<NAME>as_menu_parser_set_update_category_data</NAME>
<RETURNS>void 			</RETURNS>
AsMenuParser *mp, gboolean value
</FUNCTION>
<FUNCTION>
<NAME>as_get_system_categories</NAME>
<RETURNS>GList 			*</RETURNS>
void
</FUNCTION>
<STRUCT>
<NAME>AsMenuParser</NAME>
</STRUCT>
<MACRO>
<NAME>AS_TYPE_RELEASE</NAME>
#define AS_TYPE_RELEASE (as_release_get_type ())
</MACRO>
<STRUCT>
<NAME>AsReleaseClass</NAME>
struct _AsReleaseClass
{
	GObjectClass		parent_class;
	/*< private >*/
	void (*_as_reserved1)	(void);
	void (*_as_reserved2)	(void);
	void (*_as_reserved3)	(void);
	void (*_as_reserved4)	(void);
	void (*_as_reserved5)	(void);
	void (*_as_reserved6)	(void);
};
</STRUCT>
<ENUM>
<NAME>AsChecksumKind</NAME>
typedef enum  {
	AS_CHECKSUM_KIND_NONE,
	AS_CHECKSUM_KIND_SHA1,
	AS_CHECKSUM_KIND_SHA256,
	/*< private >*/
	AS_CHECKSUM_KIND_LAST
} AsChecksumKind;
</ENUM>
<FUNCTION>
<NAME>as_checksum_kind_to_string</NAME>
<RETURNS>const gchar 	*</RETURNS>
AsChecksumKind kind
</FUNCTION>
<FUNCTION>
<NAME>as_checksum_kind_from_string</NAME>
<RETURNS>AsChecksumKind 	</RETURNS>
const gchar *kind_str
</FUNCTION>
<ENUM>
<NAME>AsSizeKind</NAME>
typedef enum {
	AS_SIZE_KIND_UNKNOWN,
	AS_SIZE_KIND_DOWNLOAD,
	AS_SIZE_KIND_INSTALLED,
	/*< private >*/
	AS_SIZE_KIND_LAST
} AsSizeKind;
</ENUM>
<FUNCTION>
<NAME>as_size_kind_to_string</NAME>
<RETURNS>const gchar 	*</RETURNS>
AsSizeKind size_kind
</FUNCTION>
<FUNCTION>
<NAME>as_size_kind_from_string</NAME>
<RETURNS>AsSizeKind 	</RETURNS>
const gchar *size_kind
</FUNCTION>
<FUNCTION>
<NAME>as_release_new</NAME>
<RETURNS>AsRelease 	*</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>as_release_get_version</NAME>
<RETURNS>const gchar 	*</RETURNS>
AsRelease *release
</FUNCTION>
<FUNCTION>
<NAME>as_release_set_version</NAME>
<RETURNS>void 		</RETURNS>
AsRelease *release, const gchar *version
</FUNCTION>
<FUNCTION>
<NAME>as_release_get_timestamp</NAME>
<RETURNS>guint64 		</RETURNS>
AsRelease *release
</FUNCTION>
<FUNCTION>
<NAME>as_release_set_timestamp</NAME>
<RETURNS>void 		</RETURNS>
AsRelease *release, guint64 timestamp
</FUNCTION>
<FUNCTION>
<NAME>as_release_get_description</NAME>
<RETURNS>const gchar 	*</RETURNS>
AsRelease *release
</FUNCTION>
<FUNCTION>
<NAME>as_release_set_description</NAME>
<RETURNS>void 		</RETURNS>
AsRelease *release, const gchar *description, const gchar *locale
</FUNCTION>
<FUNCTION>
<NAME>as_release_get_active_locale</NAME>
<RETURNS>gchar 		*</RETURNS>
AsRelease *release
</FUNCTION>
<FUNCTION>
<NAME>as_release_set_active_locale</NAME>
<RETURNS>void 		</RETURNS>
AsRelease	*release, const gchar *locale
</FUNCTION>
<FUNCTION>
<NAME>as_release_get_locations</NAME>
<RETURNS>GPtrArray 	*</RETURNS>
AsRelease *release
</FUNCTION>
<FUNCTION>
<NAME>as_release_add_location</NAME>
<RETURNS>void 		</RETURNS>
AsRelease *release, const gchar *location
</FUNCTION>
<FUNCTION>
<NAME>as_release_get_checksum</NAME>
<RETURNS>const gchar 	*</RETURNS>
AsRelease *release, AsChecksumKind kind
</FUNCTION>
<FUNCTION>
<NAME>as_release_set_checksum</NAME>
<RETURNS>void 		</RETURNS>
AsRelease *release, const gchar *checksum, AsChecksumKind kind
</FUNCTION>
<FUNCTION>
<NAME>as_release_get_urgency</NAME>
<RETURNS>AsUrgencyKind 	</RETURNS>
AsRelease *release
</FUNCTION>
<FUNCTION>
<NAME>as_release_set_urgency</NAME>
<RETURNS>void 		</RETURNS>
AsRelease *release, AsUrgencyKind urgency
</FUNCTION>
<FUNCTION>
<NAME>as_release_get_size</NAME>
<RETURNS>guint64 		</RETURNS>
AsRelease *release, AsSizeKind kind
</FUNCTION>
<FUNCTION>
<NAME>as_release_set_size</NAME>
<RETURNS>void 		</RETURNS>
AsRelease *release, guint64 size, AsSizeKind kind
</FUNCTION>
<STRUCT>
<NAME>AsRelease</NAME>
</STRUCT>
<MACRO>
<NAME>AS_TYPE_XMLDATA</NAME>
#define AS_TYPE_XMLDATA (as_xmldata_get_type ())
</MACRO>
<STRUCT>
<NAME>AsXMLDataClass</NAME>
struct _AsXMLDataClass
{
	GObjectClass		parent_class;
	/*< private >*/
	void (*_as_reserved1)	(void);
	void (*_as_reserved2)	(void);
	void (*_as_reserved3)	(void);
	void (*_as_reserved4)	(void);
	void (*_as_reserved5)	(void);
	void (*_as_reserved6)	(void);
};
</STRUCT>
<FUNCTION>
<NAME>as_xmldata_new</NAME>
<RETURNS>AsXMLData 		*</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>as_xmldata_initialize</NAME>
<RETURNS>void 			</RETURNS>
AsXMLData *xdt, const gchar *locale, const gchar *origin, const gchar *media_baseurl, const gchar *arch, gint priority
</FUNCTION>
<FUNCTION>
<NAME>as_xmldata_parse_upstream_data</NAME>
<RETURNS>AsComponent 		*</RETURNS>
AsXMLData *xdt, const gchar *data, GError **error
</FUNCTION>
<FUNCTION>
<NAME>as_xmldata_parse_distro_data</NAME>
<RETURNS>GPtrArray 		*</RETURNS>
AsXMLData *xdt, const gchar *data, GError **error
</FUNCTION>
<FUNCTION>
<NAME>as_xmldata_update_cpt_with_upstream_data</NAME>
<RETURNS>gboolean 		</RETURNS>
AsXMLData *xdt, const gchar *data, AsComponent *cpt, GError **error
</FUNCTION>
<FUNCTION>
<NAME>as_xmldata_serialize_to_upstream</NAME>
<RETURNS>gchar 			*</RETURNS>
AsXMLData *xdt, AsComponent *cpt
</FUNCTION>
<FUNCTION>
<NAME>as_xmldata_serialize_to_distro</NAME>
<RETURNS>gchar 			*</RETURNS>
AsXMLData *xdt, GPtrArray *cpts, gboolean write_header
</FUNCTION>
<FUNCTION>
<NAME>as_xmldata_get_parser_mode</NAME>
<RETURNS>AsParserMode 		</RETURNS>
AsXMLData *xdt
</FUNCTION>
<FUNCTION>
<NAME>as_xmldata_set_parser_mode</NAME>
<RETURNS>void 			</RETURNS>
AsXMLData *xdt, AsParserMode mode
</FUNCTION>
<FUNCTION>
<NAME>as_xmldata_parse_component_node</NAME>
<RETURNS>void 			</RETURNS>
AsXMLData *metad, xmlNode *node, AsComponent *cpt, GError **error
</FUNCTION>
<FUNCTION>
<NAME>as_xmldata_parse_document</NAME>
<RETURNS>xmlDoc 			*</RETURNS>
AsXMLData *xdt, const gchar *data, GError **error
</FUNCTION>
<FUNCTION>
<NAME>as_xmldata_set_check_valid</NAME>
<RETURNS>void 			</RETURNS>
AsXMLData *xdt, gboolean check
</FUNCTION>
<STRUCT>
<NAME>AsXMLData</NAME>
</STRUCT>
<ENUM>
<NAME>AsUrlKind</NAME>
typedef enum {
	AS_URL_KIND_UNKNOWN,
	AS_URL_KIND_HOMEPAGE,
	AS_URL_KIND_BUGTRACKER,
	AS_URL_KIND_FAQ,
	AS_URL_KIND_HELP,
	AS_URL_KIND_DONATION,
	AS_URL_KIND_TRANSLATE,
	/*< private >*/
	AS_URL_KIND_LAST
} AsUrlKind;
</ENUM>
<FUNCTION>
<NAME>as_url_kind_to_string</NAME>
<RETURNS>const gchar 	*</RETURNS>
AsUrlKind url_kind
</FUNCTION>
<FUNCTION>
<NAME>as_url_kind_from_string</NAME>
<RETURNS>AsUrlKind 	</RETURNS>
const gchar *url_kind
</FUNCTION>
<ENUM>
<NAME>AsBundleKind</NAME>
typedef enum {
	AS_BUNDLE_KIND_UNKNOWN,
	AS_BUNDLE_KIND_LIMBA,
	AS_BUNDLE_KIND_FLATPAK,
	/*< private >*/
	AS_BUNDLE_KIND_LAST
} AsBundleKind;
</ENUM>
<MACRO>
<NAME>AS_BUNDLE_KIND_XDG_APP</NAME>
#define AS_BUNDLE_KIND_XDG_APP AS_BUNDLE_KIND_FLATPAK
</MACRO>
<FUNCTION>
<NAME>as_bundle_kind_to_string</NAME>
<RETURNS>const gchar 	*</RETURNS>
AsBundleKind bundle_kind
</FUNCTION>
<FUNCTION>
<NAME>as_bundle_kind_from_string</NAME>
<RETURNS>AsBundleKind 	</RETURNS>
const gchar *bundle_kind
</FUNCTION>
<ENUM>
<NAME>AsUrgencyKind</NAME>
typedef enum {
	AS_URGENCY_KIND_UNKNOWN,
	AS_URGENCY_KIND_LOW,
	AS_URGENCY_KIND_MEDIUM,
	AS_URGENCY_KIND_HIGH,
	AS_URGENCY_KIND_CRITICAL,
	/*< private >*/
	AS_URGENCY_KIND_LAST
} AsUrgencyKind;
</ENUM>
<FUNCTION>
<NAME>as_urgency_kind_to_string</NAME>
<RETURNS>const gchar 	*</RETURNS>
AsUrgencyKind urgency_kind
</FUNCTION>
<FUNCTION>
<NAME>as_urgency_kind_from_string</NAME>
<RETURNS>AsUrgencyKind 	 </RETURNS>
const gchar *urgency_kind
</FUNCTION>
<MACRO>
<NAME>AS_TYPE_PROVIDED</NAME>
#define AS_TYPE_PROVIDED (as_provided_get_type ())
</MACRO>
<STRUCT>
<NAME>AsProvidedClass</NAME>
struct _AsProvidedClass
{
	GObjectClass		parent_class;
	/*< private >*/
	void (*_as_reserved1)	(void);
	void (*_as_reserved2)	(void);
	void (*_as_reserved3)	(void);
	void (*_as_reserved4)	(void);
	void (*_as_reserved5)	(void);
	void (*_as_reserved6)	(void);
};
</STRUCT>
<ENUM>
<NAME>AsProvidedKind</NAME>
typedef enum  {
	AS_PROVIDED_KIND_UNKNOWN,
	AS_PROVIDED_KIND_LIBRARY,
	AS_PROVIDED_KIND_BINARY,
	AS_PROVIDED_KIND_MIMETYPE,
	AS_PROVIDED_KIND_FONT,
	AS_PROVIDED_KIND_MODALIAS,
	AS_PROVIDED_KIND_PYTHON_2,
	AS_PROVIDED_KIND_PYTHON,
	AS_PROVIDED_KIND_DBUS_SYSTEM,
	AS_PROVIDED_KIND_DBUS_USER,
	AS_PROVIDED_KIND_FIRMWARE_RUNTIME,
	AS_PROVIDED_KIND_FIRMWARE_FLASHED,
	/*< private >*/
	AS_PROVIDED_KIND_LAST
} AsProvidedKind;
</ENUM>
<FUNCTION>
<NAME>as_provided_kind_to_string</NAME>
<RETURNS>const gchar 		*</RETURNS>
AsProvidedKind kind
</FUNCTION>
<FUNCTION>
<NAME>as_provided_kind_from_string</NAME>
<RETURNS>AsProvidedKind 		</RETURNS>
const gchar *kind_str
</FUNCTION>
<FUNCTION>
<NAME>as_provided_kind_to_l10n_string</NAME>
<RETURNS>const gchar 		*</RETURNS>
AsProvidedKind kind
</FUNCTION>
<FUNCTION>
<NAME>as_provided_new</NAME>
<RETURNS>AsProvided 		*</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>as_provided_get_kind</NAME>
<RETURNS>AsProvidedKind 		</RETURNS>
AsProvided *prov
</FUNCTION>
<FUNCTION>
<NAME>as_provided_set_kind</NAME>
<RETURNS>void 			</RETURNS>
AsProvided *prov, AsProvidedKind kind
</FUNCTION>
<FUNCTION>
<NAME>as_provided_get_items</NAME>
<RETURNS>gchar 			**</RETURNS>
AsProvided *prov
</FUNCTION>
<FUNCTION>
<NAME>as_provided_add_item</NAME>
<RETURNS>void 			</RETURNS>
AsProvided *prov, const gchar *item
</FUNCTION>
<FUNCTION>
<NAME>as_provided_has_item</NAME>
<RETURNS>gboolean 		</RETURNS>
AsProvided *prov, const gchar *item
</FUNCTION>
<STRUCT>
<NAME>AsProvided</NAME>
</STRUCT>
<MACRO>
<NAME>AS_TYPE_DATA_POOL</NAME>
#define AS_TYPE_DATA_POOL (as_data_pool_get_type ())
</MACRO>
<STRUCT>
<NAME>AsDataPoolClass</NAME>
struct _AsDataPoolClass
{
	GObjectClass parent_class;
	/*< private >*/
	void (*_as_reserved1) (void);
	void (*_as_reserved2) (void);
	void (*_as_reserved3) (void);
	void (*_as_reserved4) (void);
	void (*_as_reserved5) (void);
	void (*_as_reserved6) (void);
};
</STRUCT>
<ENUM>
<NAME>AsCacheFlags</NAME>
typedef enum {
	AS_CACHE_FLAG_NONE = 0,
	AS_CACHE_FLAG_USE_USER   = 1 << 0,
	AS_CACHE_FLAG_USE_SYSTEM = 1 << 1,
} AsCacheFlags;
</ENUM>
<ENUM>
<NAME>AsDataPoolError</NAME>
typedef enum {
	AS_DATA_POOL_ERROR_FAILED,
	AS_DATA_POOL_ERROR_TARGET_NOT_WRITABLE,
	AS_DATA_POOL_ERROR_INCOMPLETE,
	AS_DATA_POOL_ERROR_COLLISION,
	AS_DATA_POOL_ERROR_TERM_INVALID,
	/*< private >*/
	AS_DATA_POOL_ERROR_LAST
} AsDataPoolError;
</ENUM>
<MACRO>
<NAME>AS_DATA_POOL_ERROR</NAME>
#define AS_DATA_POOL_ERROR	as_data_pool_error_quark ()
</MACRO>
<FUNCTION>
<NAME>as_data_pool_error_quark</NAME>
<RETURNS>GQuark 			</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>as_data_pool_new</NAME>
<RETURNS>AsDataPool 		*</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>as_data_pool_get_locale</NAME>
<RETURNS>const gchar  		*</RETURNS>
AsDataPool *dpool
</FUNCTION>
<FUNCTION>
<NAME>as_data_pool_set_locale</NAME>
<RETURNS>void 			</RETURNS>
AsDataPool *dpool, const gchar *locale
</FUNCTION>
<FUNCTION>
<NAME>as_data_pool_load</NAME>
<RETURNS>gboolean 		</RETURNS>
AsDataPool *dpool, GCancellable *cancellable, GError **error
</FUNCTION>
<FUNCTION>
<NAME>as_data_pool_load_metadata</NAME>
<RETURNS>gboolean 		</RETURNS>
AsDataPool *dpool
</FUNCTION>
<FUNCTION>
<NAME>as_data_pool_load_cache_file</NAME>
<RETURNS>gboolean 		</RETURNS>
AsDataPool *dpool, const gchar *fname, GError **error
</FUNCTION>
<FUNCTION>
<NAME>as_data_pool_save_cache_file</NAME>
<RETURNS>gboolean 		</RETURNS>
AsDataPool *dpool, const gchar *fname, GError **error
</FUNCTION>
<FUNCTION>
<NAME>as_data_pool_clear</NAME>
<RETURNS>void 			</RETURNS>
AsDataPool *dpool
</FUNCTION>
<FUNCTION>
<NAME>as_data_pool_add_component</NAME>
<RETURNS>gboolean 		</RETURNS>
AsDataPool *dpool, AsComponent *cpt, GError **error
</FUNCTION>
<FUNCTION>
<NAME>as_data_pool_get_components</NAME>
<RETURNS>GPtrArray 		*</RETURNS>
AsDataPool *dpool
</FUNCTION>
<FUNCTION>
<NAME>as_data_pool_get_component_by_id</NAME>
<RETURNS>AsComponent 		*</RETURNS>
AsDataPool *dpool, const gchar *id
</FUNCTION>
<FUNCTION>
<NAME>as_data_pool_get_components_by_provided_item</NAME>
<RETURNS>GPtrArray 		*</RETURNS>
AsDataPool *dpool, AsProvidedKind kind, const gchar *item, GError **error
</FUNCTION>
<FUNCTION>
<NAME>as_data_pool_get_components_by_kind</NAME>
<RETURNS>GPtrArray 		*</RETURNS>
AsDataPool *dpool, AsComponentKind kind, GError **error
</FUNCTION>
<FUNCTION>
<NAME>as_data_pool_get_components_by_categories</NAME>
<RETURNS>GPtrArray 		*</RETURNS>
AsDataPool *dpool, const gchar *categories
</FUNCTION>
<FUNCTION>
<NAME>as_data_pool_search</NAME>
<RETURNS>GPtrArray 		*</RETURNS>
AsDataPool *dpool, const gchar *search
</FUNCTION>
<FUNCTION>
<NAME>as_data_pool_get_metadata_locations</NAME>
<RETURNS>GPtrArray 		*</RETURNS>
AsDataPool *dpool
</FUNCTION>
<FUNCTION>
<NAME>as_data_pool_set_metadata_locations</NAME>
<RETURNS>void 			</RETURNS>
AsDataPool *dpool, gchar **dirs
</FUNCTION>
<FUNCTION>
<NAME>as_data_pool_get_cache_flags</NAME>
<RETURNS>AsCacheFlags 		</RETURNS>
AsDataPool *dpool
</FUNCTION>
<FUNCTION>
<NAME>as_data_pool_set_cache_flags</NAME>
<RETURNS>void 			</RETURNS>
AsDataPool *dpool, AsCacheFlags flags
</FUNCTION>
<FUNCTION>
<NAME>as_data_pool_refresh_cache</NAME>
<RETURNS>gboolean 		</RETURNS>
AsDataPool *dpool, gboolean force, GError **error
</FUNCTION>
<FUNCTION>
<NAME>as_data_pool_get_cache_age</NAME>
<RETURNS>time_t 			</RETURNS>
AsDataPool *dpool
</FUNCTION>
<FUNCTION>
<NAME>as_data_pool_update</NAME>
<DEPRECATED/>
<RETURNS>gboolean 		</RETURNS>
AsDataPool *dpool, GError **error
</FUNCTION>
<STRUCT>
<NAME>AsDataPool</NAME>
</STRUCT>
