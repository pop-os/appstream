<FUNCTION>
<NAME>as_release_get_description_table</NAME>
<RETURNS>GHashTable 	*</RETURNS>
AsRelease *release
</FUNCTION>
<FUNCTION>
<NAME>as_pool_scan_apt</NAME>
<RETURNS>void 		</RETURNS>
AsPool *pool, gboolean force, GError **error
</FUNCTION>
<FUNCTION>
<NAME>as_is_spdx_license_id</NAME>
<RETURNS>gboolean 	 </RETURNS>
const gchar *license_id
</FUNCTION>
<FUNCTION>
<NAME>as_is_spdx_license_expression</NAME>
<RETURNS>gboolean 	 </RETURNS>
const gchar *license
</FUNCTION>
<FUNCTION>
<NAME>as_spdx_license_tokenize</NAME>
<RETURNS>gchar 		**</RETURNS>
const gchar *license
</FUNCTION>
<FUNCTION>
<NAME>as_spdx_license_detokenize</NAME>
<RETURNS>gchar 		*</RETURNS>
gchar **license_tokens
</FUNCTION>
<FUNCTION>
<NAME>as_license_to_spdx_id</NAME>
<RETURNS>gchar 		*</RETURNS>
const gchar *license
</FUNCTION>
<FUNCTION>
<NAME>as_license_is_metadata_license</NAME>
<RETURNS>gboolean 	</RETURNS>
const gchar *license
</FUNCTION>
<FUNCTION>
<NAME>as_markup_convert_simple</NAME>
<RETURNS>gchar 		*</RETURNS>
const gchar *markup, GError **error
</FUNCTION>
<FUNCTION>
<NAME>as_utils_locale_is_compatible</NAME>
<RETURNS>gboolean 	</RETURNS>
const gchar *locale1, const gchar *locale2
</FUNCTION>
<FUNCTION>
<NAME>as_utils_is_category_name</NAME>
<RETURNS>gboolean 	</RETURNS>
const gchar *category_name
</FUNCTION>
<FUNCTION>
<NAME>as_utils_is_tld</NAME>
<RETURNS>gboolean 	</RETURNS>
const gchar *tld
</FUNCTION>
<FUNCTION>
<NAME>as_utils_is_desktop_environment</NAME>
<RETURNS>gboolean 	</RETURNS>
const gchar *desktop
</FUNCTION>
<FUNCTION>
<NAME>as_utils_sort_components_into_categories</NAME>
<RETURNS>void 		</RETURNS>
GPtrArray *cpts, GPtrArray *categories, gboolean check_duplicates
</FUNCTION>
<FUNCTION>
<NAME>as_utils_compare_versions</NAME>
<RETURNS>gint 		</RETURNS>
const gchar* a, const gchar *b
</FUNCTION>
<MACRO>
<NAME>AS_TYPE_YAMLDATA</NAME>
#define AS_TYPE_YAMLDATA (as_yamldata_get_type ())
</MACRO>
<STRUCT>
<NAME>AsYAMLDataClass</NAME>
struct _AsYAMLDataClass
{
	GObjectClass		parent_class;
	/*< private >*/
	void (*_as_reserved1)	(void);
	void (*_as_reserved2)	(void);
	void (*_as_reserved3)	(void);
	void (*_as_reserved4)	(void);
	void (*_as_reserved5)	(void);
	void (*_as_reserved6)	(void);
};
</STRUCT>
<FUNCTION>
<NAME>as_yamldata_new</NAME>
<RETURNS>AsYAMLData 		*</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>as_yamldata_initialize</NAME>
<RETURNS>void 			</RETURNS>
AsYAMLData *ydt, AsFormatVersion format_version, const gchar *locale, const gchar *origin, const gchar *media_baseurl, const gchar *arch, gint priority
</FUNCTION>
<FUNCTION>
<NAME>as_yamldata_parse_collection_data</NAME>
<RETURNS>GPtrArray 		*</RETURNS>
AsYAMLData *ydt, const gchar *data, GError **error
</FUNCTION>
<FUNCTION>
<NAME>as_yamldata_serialize_to_collection</NAME>
<RETURNS>gchar 			*</RETURNS>
AsYAMLData *ydt, GPtrArray *cpts, gboolean write_header, gboolean add_timestamp, GError **error
</FUNCTION>
<FUNCTION>
<NAME>as_yamldata_get_locale</NAME>
<RETURNS>const gchar 		*</RETURNS>
AsYAMLData *ydt
</FUNCTION>
<FUNCTION>
<NAME>as_yamldata_set_locale</NAME>
<RETURNS>void 			</RETURNS>
AsYAMLData *ydt, const gchar *locale
</FUNCTION>
<FUNCTION>
<NAME>as_yamldata_set_check_valid</NAME>
<RETURNS>void 			</RETURNS>
AsYAMLData *ydt, gboolean check
</FUNCTION>
<STRUCT>
<NAME>AsYAMLData</NAME>
</STRUCT>
<FUNCTION>
<NAME>as_screenshot_get_caption_table</NAME>
<RETURNS>GHashTable 		*</RETURNS>
AsScreenshot *screenshot
</FUNCTION>
<MACRO>
<NAME>AS_TYPE_IMAGE</NAME>
#define AS_TYPE_IMAGE (as_image_get_type ())
</MACRO>
<STRUCT>
<NAME>AsImageClass</NAME>
struct _AsImageClass
{
	GObjectClass		parent_class;
	/*< private >*/
	void (*_as_reserved1)	(void);
	void (*_as_reserved2)	(void);
	void (*_as_reserved3)	(void);
	void (*_as_reserved4)	(void);
	void (*_as_reserved5)	(void);
	void (*_as_reserved6)	(void);
};
</STRUCT>
<ENUM>
<NAME>AsImageKind</NAME>
typedef enum {
	AS_IMAGE_KIND_UNKNOWN,
	AS_IMAGE_KIND_SOURCE,
	AS_IMAGE_KIND_THUMBNAIL,
	/*< private >*/
	AS_IMAGE_KIND_LAST
} AsImageKind;
</ENUM>
<FUNCTION>
<NAME>as_image_kind_from_string</NAME>
<RETURNS>AsImageKind 	 </RETURNS>
const gchar *kind
</FUNCTION>
<FUNCTION>
<NAME>as_image_kind_to_string</NAME>
<RETURNS>const gchar 	*</RETURNS>
AsImageKind kind
</FUNCTION>
<FUNCTION>
<NAME>as_image_new</NAME>
<RETURNS>AsImage 		*</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>as_image_get_kind</NAME>
<RETURNS>AsImageKind 	 </RETURNS>
AsImage *image
</FUNCTION>
<FUNCTION>
<NAME>as_image_set_kind</NAME>
<RETURNS>void 		 </RETURNS>
AsImage *image, AsImageKind kind
</FUNCTION>
<FUNCTION>
<NAME>as_image_get_url</NAME>
<RETURNS>const gchar 	*</RETURNS>
AsImage *image
</FUNCTION>
<FUNCTION>
<NAME>as_image_set_url</NAME>
<RETURNS>void 		 </RETURNS>
AsImage *image, const gchar *url
</FUNCTION>
<FUNCTION>
<NAME>as_image_get_width</NAME>
<RETURNS>guint 		 </RETURNS>
AsImage *image
</FUNCTION>
<FUNCTION>
<NAME>as_image_set_width</NAME>
<RETURNS>void 		 </RETURNS>
AsImage *image, guint width
</FUNCTION>
<FUNCTION>
<NAME>as_image_get_height</NAME>
<RETURNS>guint 		 </RETURNS>
AsImage *image
</FUNCTION>
<FUNCTION>
<NAME>as_image_set_height</NAME>
<RETURNS>void 		 </RETURNS>
AsImage *image, guint height
</FUNCTION>
<FUNCTION>
<NAME>as_image_get_locale</NAME>
<RETURNS>const gchar 	*</RETURNS>
AsImage *image
</FUNCTION>
<FUNCTION>
<NAME>as_image_set_locale</NAME>
<RETURNS>void 		 </RETURNS>
AsImage *image, const gchar *locale
</FUNCTION>
<STRUCT>
<NAME>AsImage</NAME>
</STRUCT>
<MACRO>
<NAME>AS_TYPE_SUGGESTED</NAME>
#define AS_TYPE_SUGGESTED (as_suggested_get_type ())
</MACRO>
<STRUCT>
<NAME>AsSuggestedClass</NAME>
struct _AsSuggestedClass
{
	GObjectClass		parent_class;
	/*< private >*/
	void (*_as_reserved1)	(void);
	void (*_as_reserved2)	(void);
	void (*_as_reserved3)	(void);
	void (*_as_reserved4)	(void);
	void (*_as_reserved5)	(void);
	void (*_as_reserved6)	(void);
};
</STRUCT>
<ENUM>
<NAME>AsSuggestedKind</NAME>
typedef enum  {
	AS_SUGGESTED_KIND_UNKNOWN,
	AS_SUGGESTED_KIND_UPSTREAM,
	AS_SUGGESTED_KIND_HEURISTIC,
	/*< private >*/
	AS_SUGGESTED_KIND_LAST
} AsSuggestedKind;
</ENUM>
<FUNCTION>
<NAME>as_suggested_kind_from_string</NAME>
<RETURNS>AsSuggestedKind 			</RETURNS>
const gchar *kind_str
</FUNCTION>
<FUNCTION>
<NAME>as_suggested_kind_to_string</NAME>
<RETURNS>const gchar 			*</RETURNS>
AsSuggestedKind kind
</FUNCTION>
<FUNCTION>
<NAME>as_suggested_new</NAME>
<RETURNS>AsSuggested 			*</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>as_suggested_get_kind</NAME>
<RETURNS>AsSuggestedKind 			</RETURNS>
AsSuggested *suggested
</FUNCTION>
<FUNCTION>
<NAME>as_suggested_set_kind</NAME>
<RETURNS>void 				</RETURNS>
AsSuggested *suggested, AsSuggestedKind kind
</FUNCTION>
<FUNCTION>
<NAME>as_suggested_get_ids</NAME>
<RETURNS>GPtrArray 			*</RETURNS>
AsSuggested *suggested
</FUNCTION>
<FUNCTION>
<NAME>as_suggested_add_id</NAME>
<RETURNS>void 				</RETURNS>
AsSuggested *suggested, const gchar *cid
</FUNCTION>
<FUNCTION>
<NAME>as_suggested_is_valid</NAME>
<RETURNS>gboolean 			</RETURNS>
AsSuggested *suggested
</FUNCTION>
<STRUCT>
<NAME>AsSuggested</NAME>
</STRUCT>
<MACRO>
<NAME>AS_TYPE_VALIDATOR</NAME>
#define AS_TYPE_VALIDATOR (as_validator_get_type ())
</MACRO>
<STRUCT>
<NAME>AsValidatorClass</NAME>
struct _AsValidatorClass
{
	GObjectClass		parent_class;
	/*< private >*/
	void (*_as_reserved1)	(void);
	void (*_as_reserved2)	(void);
	void (*_as_reserved3)	(void);
	void (*_as_reserved4)	(void);
	void (*_as_reserved5)	(void);
	void (*_as_reserved6)	(void);
};
</STRUCT>
<FUNCTION>
<NAME>as_validator_new</NAME>
<RETURNS>AsValidator 	*</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>as_validator_clear_issues</NAME>
<RETURNS>void 		</RETURNS>
AsValidator *validator
</FUNCTION>
<FUNCTION>
<NAME>as_validator_validate_file</NAME>
<RETURNS>gboolean 	</RETURNS>
AsValidator *validator, GFile* metadata_file
</FUNCTION>
<FUNCTION>
<NAME>as_validator_validate_data</NAME>
<RETURNS>gboolean 	</RETURNS>
AsValidator *validator, const gchar *metadata
</FUNCTION>
<FUNCTION>
<NAME>as_validator_validate_tree</NAME>
<RETURNS>gboolean 	</RETURNS>
AsValidator *validator, const gchar *root_dir
</FUNCTION>
<FUNCTION>
<NAME>as_validator_get_issues</NAME>
<RETURNS>GList 		*</RETURNS>
AsValidator *validator
</FUNCTION>
<STRUCT>
<NAME>AsValidator</NAME>
</STRUCT>
<MACRO>
<NAME>AS_TYPE_BUNDLE</NAME>
#define AS_TYPE_BUNDLE (as_bundle_get_type ())
</MACRO>
<STRUCT>
<NAME>AsBundleClass</NAME>
struct _AsBundleClass
{
	GObjectClass parent_class;
	/*< private >*/
	void (*_as_reserved1) (void);
	void (*_as_reserved2) (void);
	void (*_as_reserved3) (void);
	void (*_as_reserved4) (void);
	void (*_as_reserved5) (void);
	void (*_as_reserved6) (void);
};
</STRUCT>
<ENUM>
<NAME>AsBundleKind</NAME>
typedef enum {
	AS_BUNDLE_KIND_UNKNOWN,
	AS_BUNDLE_KIND_PACKAGE,
	AS_BUNDLE_KIND_LIMBA,
	AS_BUNDLE_KIND_FLATPAK,
	AS_BUNDLE_KIND_APPIMAGE,
	AS_BUNDLE_KIND_SNAP,
	/*< private >*/
	AS_BUNDLE_KIND_LAST
} AsBundleKind;
</ENUM>
<FUNCTION>
<NAME>as_bundle_kind_to_string</NAME>
<RETURNS>const gchar 	*</RETURNS>
AsBundleKind kind
</FUNCTION>
<FUNCTION>
<NAME>as_bundle_kind_from_string</NAME>
<RETURNS>AsBundleKind 	</RETURNS>
const gchar *bundle_str
</FUNCTION>
<FUNCTION>
<NAME>as_bundle_new</NAME>
<RETURNS>AsBundle 	*</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>as_bundle_get_kind</NAME>
<RETURNS>AsBundleKind 	 </RETURNS>
AsBundle *bundle
</FUNCTION>
<FUNCTION>
<NAME>as_bundle_set_kind</NAME>
<RETURNS>void 		 </RETURNS>
AsBundle *bundle, AsBundleKind kind
</FUNCTION>
<FUNCTION>
<NAME>as_bundle_get_id</NAME>
<RETURNS>const gchar 	*</RETURNS>
AsBundle *bundle
</FUNCTION>
<FUNCTION>
<NAME>as_bundle_set_id</NAME>
<RETURNS>void 		 </RETURNS>
AsBundle *bundle, const gchar *id
</FUNCTION>
<STRUCT>
<NAME>AsBundle</NAME>
</STRUCT>
<FUNCTION>
<NAME>as_cache_file_save</NAME>
<RETURNS>void 		</RETURNS>
const gchar *fname, const gchar *locale, GPtrArray *cpts, GError **error
</FUNCTION>
<FUNCTION>
<NAME>as_cache_file_read</NAME>
<RETURNS>GPtrArray 	*</RETURNS>
const gchar *fname, GError **error
</FUNCTION>
<MACRO>
<NAME>AS_TYPE_TRANSLATION</NAME>
#define AS_TYPE_TRANSLATION (as_translation_get_type ())
</MACRO>
<STRUCT>
<NAME>AsTranslationClass</NAME>
struct _AsTranslationClass
{
	GObjectClass		parent_class;
	/*< private >*/
	void (*_as_reserved1)	(void);
	void (*_as_reserved2)	(void);
	void (*_as_reserved3)	(void);
	void (*_as_reserved4)	(void);
	void (*_as_reserved5)	(void);
	void (*_as_reserved6)	(void);
};
</STRUCT>
<ENUM>
<NAME>AsTranslationKind</NAME>
typedef enum {
	AS_TRANSLATION_KIND_UNKNOWN,
	AS_TRANSLATION_KIND_GETTEXT,
	AS_TRANSLATION_KIND_QT,
	/*< private >*/
	AS_TRANSLATION_KIND_LAST
} AsTranslationKind;
</ENUM>
<FUNCTION>
<NAME>as_translation_kind_to_string</NAME>
<RETURNS>const gchar 		*</RETURNS>
AsTranslationKind kind
</FUNCTION>
<FUNCTION>
<NAME>as_translation_kind_from_string</NAME>
<RETURNS>AsTranslationKind 	</RETURNS>
const gchar *kind_str
</FUNCTION>
<FUNCTION>
<NAME>as_translation_new</NAME>
<RETURNS>AsTranslation 		*</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>as_translation_get_kind</NAME>
<RETURNS>AsTranslationKind 	</RETURNS>
AsTranslation *tr
</FUNCTION>
<FUNCTION>
<NAME>as_translation_set_kind</NAME>
<RETURNS>void 			</RETURNS>
AsTranslation *tr, AsTranslationKind kind
</FUNCTION>
<FUNCTION>
<NAME>as_translation_get_id</NAME>
<RETURNS>const gchar 		*</RETURNS>
AsTranslation *tr
</FUNCTION>
<FUNCTION>
<NAME>as_translation_set_id</NAME>
<RETURNS>void 			</RETURNS>
AsTranslation *tr, const gchar *id
</FUNCTION>
<STRUCT>
<NAME>AsTranslation</NAME>
</STRUCT>
<MACRO>
<NAME>AS_TYPE_VALIDATOR_ISSUE</NAME>
#define AS_TYPE_VALIDATOR_ISSUE (as_validator_issue_get_type ())
</MACRO>
<STRUCT>
<NAME>AsValidatorIssueClass</NAME>
struct _AsValidatorIssueClass
{
	GObjectClass		parent_class;
	/*< private >*/
	void (*_as_reserved1)	(void);
	void (*_as_reserved2)	(void);
	void (*_as_reserved3)	(void);
	void (*_as_reserved4)	(void);
	void (*_as_reserved5)	(void);
	void (*_as_reserved6)	(void);
};
</STRUCT>
<ENUM>
<NAME>AsIssueImportance</NAME>
typedef enum {
	AS_ISSUE_IMPORTANCE_UNKNOWN,
	AS_ISSUE_IMPORTANCE_ERROR,
	AS_ISSUE_IMPORTANCE_WARNING,
	AS_ISSUE_IMPORTANCE_INFO,
	AS_ISSUE_IMPORTANCE_PEDANTIC,
	/*< private >*/
	AS_ISSUE_IMPORTANCE_LAST
} AsIssueImportance;
</ENUM>
<ENUM>
<NAME>AsIssueKind</NAME>
typedef enum {
	AS_ISSUE_KIND_UNKNOWN,
	AS_ISSUE_KIND_MARKUP_INVALID,
	AS_ISSUE_KIND_LEGACY,
	AS_ISSUE_KIND_TAG_DUPLICATED,
	AS_ISSUE_KIND_TAG_MISSING,
	AS_ISSUE_KIND_TAG_UNKNOWN,
	AS_ISSUE_KIND_TAG_NOT_ALLOWED,
	AS_ISSUE_KIND_PROPERTY_MISSING,
	AS_ISSUE_KIND_PROPERTY_INVALID,
	AS_ISSUE_KIND_VALUE_MISSING,
	AS_ISSUE_KIND_VALUE_WRONG,
	AS_ISSUE_KIND_VALUE_ISSUE,
	AS_ISSUE_KIND_FILE_MISSING,
	AS_ISSUE_KIND_WRONG_NAME,
	AS_ISSUE_KIND_READ_ERROR,
	/*< private >*/
	AS_ISSUE_KIND_LAST
} AsIssueKind;
</ENUM>
<FUNCTION>
<NAME>as_validator_issue_new</NAME>
<RETURNS>AsValidatorIssue 	*</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>as_validator_issue_get_kind</NAME>
<RETURNS>AsIssueKind 		</RETURNS>
AsValidatorIssue *issue
</FUNCTION>
<FUNCTION>
<NAME>as_validator_issue_set_kind</NAME>
<RETURNS>void 			</RETURNS>
AsValidatorIssue *issue, AsIssueKind kind
</FUNCTION>
<FUNCTION>
<NAME>as_validator_issue_get_importance</NAME>
<RETURNS>AsIssueImportance 	</RETURNS>
AsValidatorIssue *issue
</FUNCTION>
<FUNCTION>
<NAME>as_validator_issue_set_importance</NAME>
<RETURNS>void  			</RETURNS>
AsValidatorIssue *issue, AsIssueImportance importance
</FUNCTION>
<FUNCTION>
<NAME>as_validator_issue_get_message</NAME>
<RETURNS>const gchar 		*</RETURNS>
AsValidatorIssue *issue
</FUNCTION>
<FUNCTION>
<NAME>as_validator_issue_set_message</NAME>
<RETURNS>void 			</RETURNS>
AsValidatorIssue *issue, const gchar *message
</FUNCTION>
<FUNCTION>
<NAME>as_validator_issue_get_cid</NAME>
<RETURNS>const gchar 		*</RETURNS>
AsValidatorIssue *issue
</FUNCTION>
<FUNCTION>
<NAME>as_validator_issue_set_cid</NAME>
<RETURNS>void 			</RETURNS>
AsValidatorIssue *issue, const gchar *cid
</FUNCTION>
<FUNCTION>
<NAME>as_validator_issue_get_filename</NAME>
<RETURNS>const gchar 		*</RETURNS>
AsValidatorIssue *issue
</FUNCTION>
<FUNCTION>
<NAME>as_validator_issue_set_filename</NAME>
<RETURNS>void 			</RETURNS>
AsValidatorIssue *issue, const gchar *fname
</FUNCTION>
<FUNCTION>
<NAME>as_validator_issue_get_line</NAME>
<RETURNS>gint 			</RETURNS>
AsValidatorIssue *issue
</FUNCTION>
<FUNCTION>
<NAME>as_validator_issue_set_line</NAME>
<RETURNS>void 			</RETURNS>
AsValidatorIssue *issue, gint line
</FUNCTION>
<FUNCTION>
<NAME>as_validator_issue_get_location</NAME>
<RETURNS>gchar 			*</RETURNS>
AsValidatorIssue *issue
</FUNCTION>
<STRUCT>
<NAME>AsValidatorIssue</NAME>
</STRUCT>
<MACRO>
<NAME>AS_TYPE_CATEGORY</NAME>
#define AS_TYPE_CATEGORY (as_category_get_type ())
</MACRO>
<STRUCT>
<NAME>AsCategoryClass</NAME>
struct _AsCategoryClass
{
	GObjectClass parent_class;
	/*< private >*/
	void (*_as_reserved1)	(void);
	void (*_as_reserved2)	(void);
	void (*_as_reserved3)	(void);
	void (*_as_reserved4)	(void);
};
</STRUCT>
<FUNCTION>
<NAME>as_category_new</NAME>
<RETURNS>AsCategory 		*</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>as_category_get_id</NAME>
<RETURNS>const gchar 		*</RETURNS>
AsCategory *category
</FUNCTION>
<FUNCTION>
<NAME>as_category_set_id</NAME>
<RETURNS>void 			</RETURNS>
AsCategory *category, const gchar *id
</FUNCTION>
<FUNCTION>
<NAME>as_category_get_name</NAME>
<RETURNS>const gchar 		*</RETURNS>
AsCategory *category
</FUNCTION>
<FUNCTION>
<NAME>as_category_set_name</NAME>
<RETURNS>void 			</RETURNS>
AsCategory *category, const gchar *value
</FUNCTION>
<FUNCTION>
<NAME>as_category_get_summary</NAME>
<RETURNS>const gchar 		*</RETURNS>
AsCategory *category
</FUNCTION>
<FUNCTION>
<NAME>as_category_set_summary</NAME>
<RETURNS>void 			</RETURNS>
AsCategory *category, const gchar *value
</FUNCTION>
<FUNCTION>
<NAME>as_category_get_icon</NAME>
<RETURNS>const gchar 		*</RETURNS>
AsCategory *category
</FUNCTION>
<FUNCTION>
<NAME>as_category_set_icon</NAME>
<RETURNS>void 			</RETURNS>
AsCategory *category, const gchar* value
</FUNCTION>
<FUNCTION>
<NAME>as_category_get_children</NAME>
<RETURNS>GPtrArray 		*</RETURNS>
AsCategory *category
</FUNCTION>
<FUNCTION>
<NAME>as_category_has_children</NAME>
<RETURNS>gboolean 		</RETURNS>
AsCategory *category
</FUNCTION>
<FUNCTION>
<NAME>as_category_add_child</NAME>
<RETURNS>void 			</RETURNS>
AsCategory *category, AsCategory *subcat
</FUNCTION>
<FUNCTION>
<NAME>as_category_remove_child</NAME>
<RETURNS>void 			</RETURNS>
AsCategory *category, AsCategory *subcat
</FUNCTION>
<FUNCTION>
<NAME>as_category_get_desktop_groups</NAME>
<RETURNS>GPtrArray 		*</RETURNS>
AsCategory *category
</FUNCTION>
<FUNCTION>
<NAME>as_category_add_desktop_group</NAME>
<RETURNS>void 			</RETURNS>
AsCategory *category, const gchar *group_name
</FUNCTION>
<FUNCTION>
<NAME>as_category_get_components</NAME>
<RETURNS>GPtrArray 		*</RETURNS>
AsCategory *category
</FUNCTION>
<FUNCTION>
<NAME>as_category_add_component</NAME>
<RETURNS>void 			</RETURNS>
AsCategory *category, AsComponent *cpt
</FUNCTION>
<FUNCTION>
<NAME>as_category_has_component</NAME>
<RETURNS>gboolean 		</RETURNS>
AsCategory *category, AsComponent *cpt
</FUNCTION>
<FUNCTION>
<NAME>as_get_default_categories</NAME>
<RETURNS>GPtrArray 		*</RETURNS>
gboolean with_special
</FUNCTION>
<STRUCT>
<NAME>AsCategory</NAME>
</STRUCT>
<STRUCT>
<NAME>AsComponent</NAME>
</STRUCT>
<MACRO>
<NAME>AS_TYPE_DISTRO_DETAILS</NAME>
#define AS_TYPE_DISTRO_DETAILS (as_distro_details_get_type ())
</MACRO>
<STRUCT>
<NAME>AsDistroDetailsClass</NAME>
struct _AsDistroDetailsClass
{
	GObjectClass parent_class;
	/*< private >*/
	void (*_as_reserved1)	(void);
	void (*_as_reserved2)	(void);
	void (*_as_reserved3)	(void);
	void (*_as_reserved4)	(void);
	void (*_as_reserved5)	(void);
	void (*_as_reserved6)	(void);
};
</STRUCT>
<FUNCTION>
<NAME>as_distro_details_new</NAME>
<RETURNS>AsDistroDetails 		*</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>as_distro_details_get_id</NAME>
<RETURNS>const gchar 		*</RETURNS>
AsDistroDetails *distro
</FUNCTION>
<FUNCTION>
<NAME>as_distro_details_get_name</NAME>
<RETURNS>const gchar 		*</RETURNS>
AsDistroDetails *distro
</FUNCTION>
<FUNCTION>
<NAME>as_distro_details_get_version</NAME>
<RETURNS>const gchar 		*</RETURNS>
AsDistroDetails *distro
</FUNCTION>
<FUNCTION>
<NAME>as_distro_details_get_str</NAME>
<RETURNS>gchar 			*</RETURNS>
AsDistroDetails *distro, const gchar *key
</FUNCTION>
<FUNCTION>
<NAME>as_distro_details_get_bool</NAME>
<RETURNS>gboolean 		</RETURNS>
AsDistroDetails *distro, const gchar *key, gboolean default_val
</FUNCTION>
<STRUCT>
<NAME>AsDistroDetails</NAME>
</STRUCT>
<MACRO>
<NAME>AS_TYPE_SCREENSHOT</NAME>
#define AS_TYPE_SCREENSHOT (as_screenshot_get_type ())
</MACRO>
<STRUCT>
<NAME>AsScreenshotClass</NAME>
struct _AsScreenshotClass
{
	GObjectClass		parent_class;
	/*< private >*/
	void (*_as_reserved1)	(void);
	void (*_as_reserved2)	(void);
	void (*_as_reserved3)	(void);
	void (*_as_reserved4)	(void);
	void (*_as_reserved5)	(void);
	void (*_as_reserved6)	(void);
};
</STRUCT>
<ENUM>
<NAME>AsScreenshotKind</NAME>
typedef enum {
	AS_SCREENSHOT_KIND_UNKNOWN,
	AS_SCREENSHOT_KIND_DEFAULT,
	AS_SCREENSHOT_KIND_EXTRA,
	/*< private >*/
	AS_SCREENSHOT_KIND_LAST
} AsScreenshotKind;
</ENUM>
<FUNCTION>
<NAME>as_screenshot_kind_from_string</NAME>
<RETURNS>AsScreenshotKind 		</RETURNS>
const gchar *kind
</FUNCTION>
<FUNCTION>
<NAME>as_screenshot_kind_to_string</NAME>
<RETURNS>const gchar 			*</RETURNS>
AsScreenshotKind kind
</FUNCTION>
<FUNCTION>
<NAME>as_screenshot_is_valid</NAME>
<RETURNS>gboolean 			</RETURNS>
AsScreenshot *screenshot
</FUNCTION>
<FUNCTION>
<NAME>as_screenshot_new</NAME>
<RETURNS>AsScreenshot 			*</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>as_screenshot_get_kind</NAME>
<RETURNS>AsScreenshotKind 		</RETURNS>
AsScreenshot *screenshot
</FUNCTION>
<FUNCTION>
<NAME>as_screenshot_set_kind</NAME>
<RETURNS>void 		 		</RETURNS>
AsScreenshot *screenshot, AsScreenshotKind kind
</FUNCTION>
<FUNCTION>
<NAME>as_screenshot_get_caption</NAME>
<RETURNS>const gchar 			*</RETURNS>
AsScreenshot *screenshot
</FUNCTION>
<FUNCTION>
<NAME>as_screenshot_set_caption</NAME>
<RETURNS>void 				</RETURNS>
AsScreenshot *screenshot, const gchar *caption, const gchar *locale
</FUNCTION>
<FUNCTION>
<NAME>as_screenshot_get_images_all</NAME>
<RETURNS>GPtrArray 			*</RETURNS>
AsScreenshot *screenshot
</FUNCTION>
<FUNCTION>
<NAME>as_screenshot_get_images</NAME>
<RETURNS>GPtrArray 			*</RETURNS>
AsScreenshot *screenshot
</FUNCTION>
<FUNCTION>
<NAME>as_screenshot_add_image</NAME>
<RETURNS>void 				</RETURNS>
AsScreenshot *screenshot, AsImage *image
</FUNCTION>
<FUNCTION>
<NAME>as_screenshot_get_active_locale</NAME>
<RETURNS>gchar 				*</RETURNS>
AsScreenshot *screenshot
</FUNCTION>
<FUNCTION>
<NAME>as_screenshot_set_active_locale</NAME>
<RETURNS>void 				</RETURNS>
AsScreenshot *screenshot, const gchar *locale
</FUNCTION>
<STRUCT>
<NAME>AsScreenshot</NAME>
</STRUCT>
<FUNCTION>
<NAME>as_pool_get_cache_age</NAME>
<RETURNS>time_t 			</RETURNS>
AsPool *pool
</FUNCTION>
<MACRO>
<NAME>AS_TYPE_CHECKSUM</NAME>
#define AS_TYPE_CHECKSUM (as_checksum_get_type ())
</MACRO>
<STRUCT>
<NAME>AsChecksumClass</NAME>
struct _AsChecksumClass
{
	GObjectClass parent_class;
	/*< private >*/
	void (*_as_reserved1) (void);
	void (*_as_reserved2) (void);
	void (*_as_reserved3) (void);
	void (*_as_reserved4) (void);
	void (*_as_reserved5) (void);
	void (*_as_reserved6) (void);
};
</STRUCT>
<ENUM>
<NAME>AsChecksumKind</NAME>
typedef enum  {
	AS_CHECKSUM_KIND_NONE,
	AS_CHECKSUM_KIND_SHA1,
	AS_CHECKSUM_KIND_SHA256,
	/*< private >*/
	AS_CHECKSUM_KIND_LAST
} AsChecksumKind;
</ENUM>
<FUNCTION>
<NAME>as_checksum_kind_to_string</NAME>
<RETURNS>const gchar 		*</RETURNS>
AsChecksumKind kind
</FUNCTION>
<FUNCTION>
<NAME>as_checksum_kind_from_string</NAME>
<RETURNS>AsChecksumKind 		</RETURNS>
const gchar *kind_str
</FUNCTION>
<FUNCTION>
<NAME>as_checksum_new</NAME>
<RETURNS>AsChecksum 		*</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>as_checksum_get_kind</NAME>
<RETURNS>AsChecksumKind 		</RETURNS>
AsChecksum *cs
</FUNCTION>
<FUNCTION>
<NAME>as_checksum_set_kind</NAME>
<RETURNS>void 			</RETURNS>
AsChecksum *cs, AsChecksumKind kind
</FUNCTION>
<FUNCTION>
<NAME>as_checksum_get_value</NAME>
<RETURNS>const gchar 		*</RETURNS>
AsChecksum *cs
</FUNCTION>
<FUNCTION>
<NAME>as_checksum_set_value</NAME>
<RETURNS>void 			</RETURNS>
AsChecksum *cs, const gchar *value
</FUNCTION>
<STRUCT>
<NAME>AsChecksum</NAME>
</STRUCT>
<MACRO>
<NAME>AS_TYPE_POOL</NAME>
#define AS_TYPE_POOL (as_pool_get_type ())
</MACRO>
<STRUCT>
<NAME>AsPoolClass</NAME>
struct _AsPoolClass
{
	GObjectClass parent_class;
	/*< private >*/
	void (*_as_reserved1) (void);
	void (*_as_reserved2) (void);
	void (*_as_reserved3) (void);
	void (*_as_reserved4) (void);
	void (*_as_reserved5) (void);
	void (*_as_reserved6) (void);
};
</STRUCT>
<ENUM>
<NAME>AsCacheFlags</NAME>
typedef enum {
	AS_CACHE_FLAG_NONE = 0,
	AS_CACHE_FLAG_USE_USER   = 1 << 0,
	AS_CACHE_FLAG_USE_SYSTEM = 1 << 1,
} AsCacheFlags;
</ENUM>
<ENUM>
<NAME>AsPoolFlags</NAME>
typedef enum {
	AS_POOL_FLAG_NONE = 0,
	AS_POOL_FLAG_READ_COLLECTION    = 1 << 0,
	AS_POOL_FLAG_READ_METAINFO      = 1 << 1,
	AS_POOL_FLAG_READ_DESKTOP_FILES = 1 << 2,
} AsPoolFlags;
</ENUM>
<ENUM>
<NAME>AsPoolError</NAME>
typedef enum {
	AS_POOL_ERROR_FAILED,
	AS_POOL_ERROR_TARGET_NOT_WRITABLE,
	AS_POOL_ERROR_INCOMPLETE,
	AS_POOL_ERROR_COLLISION,
	/*< private >*/
	AS_POOL_ERROR_LAST
} AsPoolError;
</ENUM>
<MACRO>
<NAME>AS_POOL_ERROR</NAME>
#define AS_POOL_ERROR	as_pool_error_quark ()
</MACRO>
<FUNCTION>
<NAME>as_pool_error_quark</NAME>
<RETURNS>GQuark 			</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>as_pool_new</NAME>
<RETURNS>AsPool 			*</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>as_pool_get_locale</NAME>
<RETURNS>const gchar  		*</RETURNS>
AsPool *pool
</FUNCTION>
<FUNCTION>
<NAME>as_pool_set_locale</NAME>
<RETURNS>void 			</RETURNS>
AsPool *pool, const gchar *locale
</FUNCTION>
<FUNCTION>
<NAME>as_pool_load</NAME>
<RETURNS>gboolean 		</RETURNS>
AsPool *pool, GCancellable *cancellable, GError **error
</FUNCTION>
<FUNCTION>
<NAME>as_pool_load_cache_file</NAME>
<RETURNS>gboolean 		</RETURNS>
AsPool *pool, const gchar *fname, GError **error
</FUNCTION>
<FUNCTION>
<NAME>as_pool_save_cache_file</NAME>
<RETURNS>gboolean 		</RETURNS>
AsPool *pool, const gchar *fname, GError **error
</FUNCTION>
<FUNCTION>
<NAME>as_pool_clear</NAME>
<RETURNS>void 			</RETURNS>
AsPool *pool
</FUNCTION>
<FUNCTION>
<NAME>as_pool_add_component</NAME>
<RETURNS>gboolean 		</RETURNS>
AsPool *pool, AsComponent *cpt, GError **error
</FUNCTION>
<FUNCTION>
<NAME>as_pool_get_components</NAME>
<RETURNS>GPtrArray 		*</RETURNS>
AsPool *pool
</FUNCTION>
<FUNCTION>
<NAME>as_pool_get_components_by_id</NAME>
<RETURNS>GPtrArray 		*</RETURNS>
AsPool *pool, const gchar *cid
</FUNCTION>
<FUNCTION>
<NAME>as_pool_get_components_by_provided_item</NAME>
<RETURNS>GPtrArray 		*</RETURNS>
AsPool *pool, AsProvidedKind kind, const gchar *item
</FUNCTION>
<FUNCTION>
<NAME>as_pool_get_components_by_kind</NAME>
<RETURNS>GPtrArray 		*</RETURNS>
AsPool *pool, AsComponentKind kind
</FUNCTION>
<FUNCTION>
<NAME>as_pool_get_components_by_categories</NAME>
<RETURNS>GPtrArray 		*</RETURNS>
AsPool *pool, gchar **categories
</FUNCTION>
<FUNCTION>
<NAME>as_pool_search</NAME>
<RETURNS>GPtrArray 		*</RETURNS>
AsPool *pool, const gchar *search
</FUNCTION>
<FUNCTION>
<NAME>as_pool_clear_metadata_locations</NAME>
<RETURNS>void 			</RETURNS>
AsPool *pool
</FUNCTION>
<FUNCTION>
<NAME>as_pool_add_metadata_location</NAME>
<RETURNS>void 			</RETURNS>
AsPool *pool, const gchar *directory
</FUNCTION>
<FUNCTION>
<NAME>as_pool_get_cache_flags</NAME>
<RETURNS>AsCacheFlags 		</RETURNS>
AsPool *pool
</FUNCTION>
<FUNCTION>
<NAME>as_pool_set_cache_flags</NAME>
<RETURNS>void 			</RETURNS>
AsPool *pool, AsCacheFlags flags
</FUNCTION>
<FUNCTION>
<NAME>as_pool_get_flags</NAME>
<RETURNS>AsPoolFlags 		</RETURNS>
AsPool *pool
</FUNCTION>
<FUNCTION>
<NAME>as_pool_set_flags</NAME>
<RETURNS>void 			</RETURNS>
AsPool *pool, AsPoolFlags flags
</FUNCTION>
<FUNCTION>
<NAME>as_pool_refresh_cache</NAME>
<RETURNS>gboolean 		</RETURNS>
AsPool *pool, gboolean force, GError **error
</FUNCTION>
<STRUCT>
<NAME>AsPool</NAME>
</STRUCT>
<MACRO>
<NAME>AS_TYPE_COMPONENT</NAME>
#define AS_TYPE_COMPONENT (as_component_get_type ())
</MACRO>
<STRUCT>
<NAME>AsComponentClass</NAME>
struct _AsComponentClass
{
	GObjectClass		parent_class;
	/*< private >*/
	void (*_as_reserved1)	(void);
	void (*_as_reserved2)	(void);
	void (*_as_reserved3)	(void);
	void (*_as_reserved4)	(void);
	void (*_as_reserved5)	(void);
	void (*_as_reserved6)	(void);
};
</STRUCT>
<ENUM>
<NAME>AsComponentKind</NAME>
typedef enum  {
	AS_COMPONENT_KIND_UNKNOWN,
	AS_COMPONENT_KIND_GENERIC,
	AS_COMPONENT_KIND_DESKTOP_APP,
	AS_COMPONENT_KIND_CONSOLE_APP,
	AS_COMPONENT_KIND_WEB_APP,
	AS_COMPONENT_KIND_ADDON,
	AS_COMPONENT_KIND_FONT,
	AS_COMPONENT_KIND_CODEC,
	AS_COMPONENT_KIND_INPUTMETHOD,
	AS_COMPONENT_KIND_FIRMWARE,
	AS_COMPONENT_KIND_DRIVER,
	AS_COMPONENT_KIND_LOCALIZATION,
	/*< private >*/
	AS_COMPONENT_KIND_LAST
} AsComponentKind;
</ENUM>
<MACRO>
<NAME>AS_TYPE_COMPONENT_KIND</NAME>
#define AS_TYPE_COMPONENT_KIND (as_component_kind_get_type ())
</MACRO>
<FUNCTION>
<NAME>as_component_kind_get_type</NAME>
<RETURNS>GType 			</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>as_component_kind_to_string</NAME>
<RETURNS>const gchar 		*</RETURNS>
AsComponentKind kind
</FUNCTION>
<FUNCTION>
<NAME>as_component_kind_from_string</NAME>
<RETURNS>AsComponentKind 		</RETURNS>
const gchar *kind_str
</FUNCTION>
<ENUM>
<NAME>AsMergeKind</NAME>
typedef enum  {
	AS_MERGE_KIND_NONE,
	AS_MERGE_KIND_REPLACE,
	AS_MERGE_KIND_APPEND,
	/*< private >*/
	AS_MERGE_KIND_LAST
} AsMergeKind;
</ENUM>
<FUNCTION>
<NAME>as_merge_kind_to_string</NAME>
<RETURNS>const gchar 		*</RETURNS>
AsMergeKind kind
</FUNCTION>
<FUNCTION>
<NAME>as_merge_kind_from_string</NAME>
<RETURNS>AsMergeKind 		</RETURNS>
const gchar *kind_str
</FUNCTION>
<ENUM>
<NAME>AsValueFlags</NAME>
typedef enum {
	AS_VALUE_FLAG_NONE = 0,
	AS_VALUE_FLAG_DUPLICATE_CHECK = 1 << 0,
	AS_VALUE_FLAG_NO_TRANSLATION_FALLBACK = 1 << 1
} AsValueFlags;
</ENUM>
<FUNCTION>
<NAME>as_component_new</NAME>
<RETURNS>AsComponent 		*</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>as_component_get_value_flags</NAME>
<RETURNS>AsValueFlags 		</RETURNS>
AsComponent *cpt
</FUNCTION>
<FUNCTION>
<NAME>as_component_set_value_flags</NAME>
<RETURNS>void 			</RETURNS>
AsComponent *cpt, AsValueFlags flags
</FUNCTION>
<FUNCTION>
<NAME>as_component_get_active_locale</NAME>
<RETURNS>gchar 			*</RETURNS>
AsComponent *cpt
</FUNCTION>
<FUNCTION>
<NAME>as_component_set_active_locale</NAME>
<RETURNS>void 			</RETURNS>
AsComponent *cpt, const gchar *locale
</FUNCTION>
<FUNCTION>
<NAME>as_component_get_id</NAME>
<RETURNS>const gchar 		*</RETURNS>
AsComponent *cpt
</FUNCTION>
<FUNCTION>
<NAME>as_component_set_id</NAME>
<RETURNS>void 			</RETURNS>
AsComponent *cpt, const gchar *value
</FUNCTION>
<FUNCTION>
<NAME>as_component_get_data_id</NAME>
<RETURNS>const gchar 		*</RETURNS>
AsComponent *cpt
</FUNCTION>
<FUNCTION>
<NAME>as_component_set_data_id</NAME>
<RETURNS>void 			</RETURNS>
AsComponent *cpt, const gchar *value
</FUNCTION>
<FUNCTION>
<NAME>as_component_get_kind</NAME>
<RETURNS>AsComponentKind 		</RETURNS>
AsComponent *cpt
</FUNCTION>
<FUNCTION>
<NAME>as_component_set_kind</NAME>
<RETURNS>void 			</RETURNS>
AsComponent *cpt, AsComponentKind value
</FUNCTION>
<FUNCTION>
<NAME>as_component_get_desktop_id</NAME>
<RETURNS>const gchar 		*</RETURNS>
AsComponent *cpt
</FUNCTION>
<FUNCTION>
<NAME>as_component_get_origin</NAME>
<RETURNS>const gchar 		*</RETURNS>
AsComponent *cpt
</FUNCTION>
<FUNCTION>
<NAME>as_component_set_origin</NAME>
<RETURNS>void 			</RETURNS>
AsComponent *cpt, const gchar *origin
</FUNCTION>
<FUNCTION>
<NAME>as_component_get_pkgname</NAME>
<RETURNS>gchar 			*</RETURNS>
AsComponent *cpt
</FUNCTION>
<FUNCTION>
<NAME>as_component_get_pkgnames</NAME>
<RETURNS>gchar 			**</RETURNS>
AsComponent *cpt
</FUNCTION>
<FUNCTION>
<NAME>as_component_set_pkgnames</NAME>
<RETURNS>void 			</RETURNS>
AsComponent *cpt, gchar **packages
</FUNCTION>
<FUNCTION>
<NAME>as_component_get_source_pkgname</NAME>
<RETURNS>const gchar 		*</RETURNS>
AsComponent *cpt
</FUNCTION>
<FUNCTION>
<NAME>as_component_set_source_pkgname</NAME>
<RETURNS>void 			</RETURNS>
AsComponent *cpt, const gchar *spkgname
</FUNCTION>
<FUNCTION>
<NAME>as_component_get_name</NAME>
<RETURNS>const gchar 		*</RETURNS>
AsComponent *cpt
</FUNCTION>
<FUNCTION>
<NAME>as_component_set_name</NAME>
<RETURNS>void 			</RETURNS>
AsComponent *cpt, const gchar *value, const gchar *locale
</FUNCTION>
<FUNCTION>
<NAME>as_component_get_summary</NAME>
<RETURNS>const gchar 		*</RETURNS>
AsComponent *cpt
</FUNCTION>
<FUNCTION>
<NAME>as_component_set_summary</NAME>
<RETURNS>void 			</RETURNS>
AsComponent *cpt, const gchar *value, const gchar *locale
</FUNCTION>
<FUNCTION>
<NAME>as_component_get_description</NAME>
<RETURNS>const gchar 		*</RETURNS>
AsComponent *cpt
</FUNCTION>
<FUNCTION>
<NAME>as_component_set_description</NAME>
<RETURNS>void 			</RETURNS>
AsComponent *cpt, const gchar *value, const gchar *locale
</FUNCTION>
<FUNCTION>
<NAME>as_component_get_metadata_license</NAME>
<RETURNS>const gchar 		*</RETURNS>
AsComponent *cpt
</FUNCTION>
<FUNCTION>
<NAME>as_component_set_metadata_license</NAME>
<RETURNS>void 			</RETURNS>
AsComponent *cpt, const gchar *value
</FUNCTION>
<FUNCTION>
<NAME>as_component_get_project_license</NAME>
<RETURNS>const gchar 		*</RETURNS>
AsComponent *cpt
</FUNCTION>
<FUNCTION>
<NAME>as_component_set_project_license</NAME>
<RETURNS>void 			</RETURNS>
AsComponent *cpt, const gchar *value
</FUNCTION>
<FUNCTION>
<NAME>as_component_get_project_group</NAME>
<RETURNS>const gchar 		*</RETURNS>
AsComponent *cpt
</FUNCTION>
<FUNCTION>
<NAME>as_component_set_project_group</NAME>
<RETURNS>void 			</RETURNS>
AsComponent *cpt, const gchar *value
</FUNCTION>
<FUNCTION>
<NAME>as_component_get_developer_name</NAME>
<RETURNS>const gchar 		*</RETURNS>
AsComponent *cpt
</FUNCTION>
<FUNCTION>
<NAME>as_component_set_developer_name</NAME>
<RETURNS>void 			</RETURNS>
AsComponent *cpt, const gchar *value, const gchar *locale
</FUNCTION>
<FUNCTION>
<NAME>as_component_get_compulsory_for_desktops</NAME>
<RETURNS>GPtrArray 		*</RETURNS>
AsComponent *cpt
</FUNCTION>
<FUNCTION>
<NAME>as_component_set_compulsory_for_desktop</NAME>
<RETURNS>void 			</RETURNS>
AsComponent *cpt, const gchar *desktop
</FUNCTION>
<FUNCTION>
<NAME>as_component_is_compulsory_for_desktop</NAME>
<RETURNS>gboolean 		</RETURNS>
AsComponent *cpt, const gchar *desktop
</FUNCTION>
<FUNCTION>
<NAME>as_component_get_categories</NAME>
<RETURNS>GPtrArray 		*</RETURNS>
AsComponent *cpt
</FUNCTION>
<FUNCTION>
<NAME>as_component_add_category</NAME>
<RETURNS>void 			</RETURNS>
AsComponent *cpt, const gchar *category
</FUNCTION>
<FUNCTION>
<NAME>as_component_has_category</NAME>
<RETURNS>gboolean 		</RETURNS>
AsComponent *cpt, const gchar *category
</FUNCTION>
<FUNCTION>
<NAME>as_component_get_screenshots</NAME>
<RETURNS>GPtrArray 		*</RETURNS>
AsComponent *cpt
</FUNCTION>
<FUNCTION>
<NAME>as_component_add_screenshot</NAME>
<RETURNS>void 			</RETURNS>
AsComponent *cpt, AsScreenshot *sshot
</FUNCTION>
<FUNCTION>
<NAME>as_component_get_keywords</NAME>
<RETURNS>gchar 			**</RETURNS>
AsComponent *cpt
</FUNCTION>
<FUNCTION>
<NAME>as_component_set_keywords</NAME>
<RETURNS>void 			</RETURNS>
AsComponent *cpt, gchar **value, const gchar *locale
</FUNCTION>
<FUNCTION>
<NAME>as_component_get_icons</NAME>
<RETURNS>GPtrArray 		*</RETURNS>
AsComponent *cpt
</FUNCTION>
<FUNCTION>
<NAME>as_component_get_icon_by_size</NAME>
<RETURNS>AsIcon 			*</RETURNS>
AsComponent *cpt, guint width, guint height
</FUNCTION>
<FUNCTION>
<NAME>as_component_add_icon</NAME>
<RETURNS>void 			</RETURNS>
AsComponent *cpt, AsIcon *icon
</FUNCTION>
<FUNCTION>
<NAME>as_component_get_provided</NAME>
<RETURNS>GPtrArray 		*</RETURNS>
AsComponent *cpt
</FUNCTION>
<FUNCTION>
<NAME>as_component_add_provided</NAME>
<RETURNS>void 			</RETURNS>
AsComponent *cpt, AsProvided *prov
</FUNCTION>
<FUNCTION>
<NAME>as_component_get_provided_for_kind</NAME>
<RETURNS>AsProvided 		*</RETURNS>
AsComponent *cpt, AsProvidedKind kind
</FUNCTION>
<FUNCTION>
<NAME>as_component_get_url</NAME>
<RETURNS>const gchar 		*</RETURNS>
AsComponent *cpt, AsUrlKind url_kind
</FUNCTION>
<FUNCTION>
<NAME>as_component_add_url</NAME>
<RETURNS>void 			</RETURNS>
AsComponent *cpt, AsUrlKind url_kind, const gchar *url
</FUNCTION>
<FUNCTION>
<NAME>as_component_get_releases</NAME>
<RETURNS>GPtrArray 		*</RETURNS>
AsComponent *cpt
</FUNCTION>
<FUNCTION>
<NAME>as_component_add_release</NAME>
<RETURNS>void 			</RETURNS>
AsComponent *cpt, AsRelease* release
</FUNCTION>
<FUNCTION>
<NAME>as_component_get_extends</NAME>
<RETURNS>GPtrArray 		*</RETURNS>
AsComponent *cpt
</FUNCTION>
<FUNCTION>
<NAME>as_component_add_extends</NAME>
<RETURNS>void 			</RETURNS>
AsComponent *cpt, const gchar *cpt_id
</FUNCTION>
<FUNCTION>
<NAME>as_component_get_addons</NAME>
<RETURNS>GPtrArray 		*</RETURNS>
AsComponent *cpt
</FUNCTION>
<FUNCTION>
<NAME>as_component_add_addon</NAME>
<RETURNS>void 			</RETURNS>
AsComponent *cpt, AsComponent *addon
</FUNCTION>
<FUNCTION>
<NAME>as_component_get_languages</NAME>
<RETURNS>GList 			*</RETURNS>
AsComponent *cpt
</FUNCTION>
<FUNCTION>
<NAME>as_component_get_language</NAME>
<RETURNS>gint 			</RETURNS>
AsComponent *cpt, const gchar *locale
</FUNCTION>
<FUNCTION>
<NAME>as_component_add_language</NAME>
<RETURNS>void 			</RETURNS>
AsComponent *cpt, const gchar *locale, gint percentage
</FUNCTION>
<FUNCTION>
<NAME>as_component_get_translations</NAME>
<RETURNS>GPtrArray 		*</RETURNS>
AsComponent *cpt
</FUNCTION>
<FUNCTION>
<NAME>as_component_add_translation</NAME>
<RETURNS>void 			</RETURNS>
AsComponent *cpt, AsTranslation *tr
</FUNCTION>
<FUNCTION>
<NAME>as_component_has_bundle</NAME>
<RETURNS>gboolean 		</RETURNS>
AsComponent *cpt
</FUNCTION>
<FUNCTION>
<NAME>as_component_get_bundles</NAME>
<RETURNS>GPtrArray 		*</RETURNS>
AsComponent *cpt
</FUNCTION>
<FUNCTION>
<NAME>as_component_get_bundle</NAME>
<RETURNS>AsBundle 		*</RETURNS>
AsComponent *cpt, AsBundleKind bundle_kind
</FUNCTION>
<FUNCTION>
<NAME>as_component_add_bundle</NAME>
<RETURNS>void 			</RETURNS>
AsComponent *cpt, AsBundle *bundle
</FUNCTION>
<FUNCTION>
<NAME>as_component_get_suggested</NAME>
<RETURNS>GPtrArray 		*</RETURNS>
AsComponent *cpt
</FUNCTION>
<FUNCTION>
<NAME>as_component_add_suggested</NAME>
<RETURNS>void 			</RETURNS>
AsComponent *cpt, AsSuggested *suggested
</FUNCTION>
<FUNCTION>
<NAME>as_component_get_search_tokens</NAME>
<RETURNS>GPtrArray 		*</RETURNS>
AsComponent *cpt
</FUNCTION>
<FUNCTION>
<NAME>as_component_search_matches</NAME>
<RETURNS>guint 			</RETURNS>
AsComponent *cpt, const gchar *term
</FUNCTION>
<FUNCTION>
<NAME>as_component_search_matches_all</NAME>
<RETURNS>guint 			</RETURNS>
AsComponent *cpt, gchar **terms
</FUNCTION>
<FUNCTION>
<NAME>as_component_get_merge_kind</NAME>
<RETURNS>AsMergeKind 		</RETURNS>
AsComponent *cpt
</FUNCTION>
<FUNCTION>
<NAME>as_component_set_merge_kind</NAME>
<RETURNS>void 			</RETURNS>
AsComponent *cpt, AsMergeKind kind
</FUNCTION>
<FUNCTION>
<NAME>as_component_is_member_of_category</NAME>
<RETURNS>gboolean 		</RETURNS>
AsComponent *cpt, AsCategory *category
</FUNCTION>
<FUNCTION>
<NAME>as_component_is_ignored</NAME>
<RETURNS>gboolean 		</RETURNS>
AsComponent *cpt
</FUNCTION>
<FUNCTION>
<NAME>as_component_is_valid</NAME>
<RETURNS>gboolean 		</RETURNS>
AsComponent *cpt
</FUNCTION>
<FUNCTION>
<NAME>as_component_to_string</NAME>
<RETURNS>gchar 			*</RETURNS>
AsComponent *cpt
</FUNCTION>
<STRUCT>
<NAME>AsComponent</NAME>
</STRUCT>
<MACRO>
<NAME>AS_TYPE_STEMMER</NAME>
#define AS_TYPE_STEMMER	(as_stemmer_get_type ())
</MACRO>
<FUNCTION>
<NAME>as_stemmer_get</NAME>
<RETURNS>AsStemmer 		*</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>as_stemmer_reload</NAME>
<RETURNS>void 			</RETURNS>
AsStemmer *stemmer, const gchar *lang
</FUNCTION>
<FUNCTION>
<NAME>as_stemmer_stem</NAME>
<RETURNS>gchar 			*</RETURNS>
AsStemmer *stemmer, const gchar *term
</FUNCTION>
<STRUCT>
<NAME>AsStemmer</NAME>
</STRUCT>
<MACRO>
<NAME>AS_TYPE_ICON</NAME>
#define AS_TYPE_ICON (as_icon_get_type ())
</MACRO>
<STRUCT>
<NAME>AsIconClass</NAME>
struct _AsIconClass
{
	GObjectClass		parent_class;
	/*< private >*/
	void (*_as_reserved1)	(void);
	void (*_as_reserved2)	(void);
	void (*_as_reserved3)	(void);
	void (*_as_reserved4)	(void);
	void (*_as_reserved5)	(void);
	void (*_as_reserved6)	(void);
};
</STRUCT>
<ENUM>
<NAME>AsIconKind</NAME>
typedef enum  {
	AS_ICON_KIND_UNKNOWN,
	AS_ICON_KIND_CACHED,
	AS_ICON_KIND_STOCK,
	AS_ICON_KIND_LOCAL,
	AS_ICON_KIND_REMOTE,
	/*< private >*/
	AS_ICON_KIND_LAST
} AsIconKind;
</ENUM>
<FUNCTION>
<NAME>as_icon_kind_from_string</NAME>
<RETURNS>AsIconKind 	</RETURNS>
const gchar *kind_str
</FUNCTION>
<FUNCTION>
<NAME>as_icon_kind_to_string</NAME>
<RETURNS>const gchar 	*</RETURNS>
AsIconKind kind
</FUNCTION>
<FUNCTION>
<NAME>as_icon_new</NAME>
<RETURNS>AsIcon 		*</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>as_icon_get_kind</NAME>
<RETURNS>AsIconKind 	 </RETURNS>
AsIcon *icon
</FUNCTION>
<FUNCTION>
<NAME>as_icon_set_kind</NAME>
<RETURNS>void 		 </RETURNS>
AsIcon *icon, AsIconKind kind
</FUNCTION>
<FUNCTION>
<NAME>as_icon_get_name</NAME>
<RETURNS>const gchar 	*</RETURNS>
AsIcon *icon
</FUNCTION>
<FUNCTION>
<NAME>as_icon_set_name</NAME>
<RETURNS>void 		 </RETURNS>
AsIcon *icon, const gchar *name
</FUNCTION>
<FUNCTION>
<NAME>as_icon_get_url</NAME>
<RETURNS>const gchar 	*</RETURNS>
AsIcon *icon
</FUNCTION>
<FUNCTION>
<NAME>as_icon_set_url</NAME>
<RETURNS>void 		 </RETURNS>
AsIcon *icon, const gchar *url
</FUNCTION>
<FUNCTION>
<NAME>as_icon_get_filename</NAME>
<RETURNS>const gchar 	*</RETURNS>
AsIcon *icon
</FUNCTION>
<FUNCTION>
<NAME>as_icon_set_filename</NAME>
<RETURNS>void 		 </RETURNS>
AsIcon *icon, const gchar *filename
</FUNCTION>
<FUNCTION>
<NAME>as_icon_get_width</NAME>
<RETURNS>guint 		 </RETURNS>
AsIcon *icon
</FUNCTION>
<FUNCTION>
<NAME>as_icon_set_width</NAME>
<RETURNS>void 		 </RETURNS>
AsIcon *icon, guint width
</FUNCTION>
<FUNCTION>
<NAME>as_icon_get_height</NAME>
<RETURNS>guint 		 </RETURNS>
AsIcon *icon
</FUNCTION>
<FUNCTION>
<NAME>as_icon_set_height</NAME>
<RETURNS>void 		 </RETURNS>
AsIcon *icon, guint height
</FUNCTION>
<STRUCT>
<NAME>AsIcon</NAME>
</STRUCT>
<MACRO>
<NAME>AS_TYPE_METADATA</NAME>
#define AS_TYPE_METADATA (as_metadata_get_type ())
</MACRO>
<STRUCT>
<NAME>AsMetadataClass</NAME>
struct _AsMetadataClass
{
	GObjectClass		parent_class;
	/*< private >*/
	void (*_as_reserved1)	(void);
	void (*_as_reserved2)	(void);
	void (*_as_reserved3)	(void);
	void (*_as_reserved4)	(void);
	void (*_as_reserved5)	(void);
	void (*_as_reserved6)	(void);
};
</STRUCT>
<ENUM>
<NAME>AsFormatStyle</NAME>
typedef enum {
	AS_FORMAT_STYLE_UNKNOWN,
	AS_FORMAT_STYLE_METAINFO,
	AS_FORMAT_STYLE_COLLECTION,
	/*< private >*/
	AS_FORMAT_STYLE_LAST
} AsFormatStyle;
</ENUM>
<ENUM>
<NAME>AsFormatKind</NAME>
typedef enum {
	AS_FORMAT_KIND_UNKNOWN,
	AS_FORMAT_KIND_XML,
	AS_FORMAT_KIND_YAML,
	AS_FORMAT_KIND_DESKTOP_ENTRY,
	/*< private >*/
	AS_FORMAT_KIND_LAST
} AsFormatKind;
</ENUM>
<FUNCTION>
<NAME>as_format_kind_to_string</NAME>
<RETURNS>const gchar 		*</RETURNS>
AsFormatKind kind
</FUNCTION>
<FUNCTION>
<NAME>as_format_kind_from_string</NAME>
<RETURNS>AsFormatKind 		 </RETURNS>
const gchar *kind_str
</FUNCTION>
<ENUM>
<NAME>AsFormatVersion</NAME>
typedef enum {
	AS_FORMAT_VERSION_V0_6,
	AS_FORMAT_VERSION_V0_7,
	AS_FORMAT_VERSION_V0_8,
	AS_FORMAT_VERSION_V0_9,
	AS_FORMAT_VERSION_V0_10,
	/*< private >*/
	AS_FORMAT_VERSION_LAST
} AsFormatVersion;
</ENUM>
<FUNCTION>
<NAME>as_format_version_to_string</NAME>
<RETURNS>const gchar 		*</RETURNS>
AsFormatVersion version
</FUNCTION>
<FUNCTION>
<NAME>as_format_version_from_string</NAME>
<RETURNS>AsFormatVersion 		 </RETURNS>
const gchar *version_str
</FUNCTION>
<MACRO>
<NAME>AS_CURRENT_FORMAT_VERSION</NAME>
#define AS_CURRENT_FORMAT_VERSION AS_FORMAT_VERSION_V0_10
</MACRO>
<ENUM>
<NAME>AsMetadataError</NAME>
typedef enum {
	AS_METADATA_ERROR_FAILED,
	AS_METADATA_ERROR_PARSE,
	AS_METADATA_ERROR_FORMAT_UNEXPECTED,
	AS_METADATA_ERROR_NO_COMPONENT,
	/*< private >*/
	AS_METADATA_ERROR_LAST
} AsMetadataError;
</ENUM>
<MACRO>
<NAME>AS_METADATA_ERROR</NAME>
#define	AS_METADATA_ERROR	as_metadata_error_quark ()
</MACRO>
<FUNCTION>
<NAME>as_metadata_new</NAME>
<RETURNS>AsMetadata 		*</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>as_metadata_error_quark</NAME>
<RETURNS>GQuark 			</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>as_metadata_parse_file</NAME>
<RETURNS>void 			</RETURNS>
AsMetadata *metad, GFile *file, AsFormatKind format, GError **error
</FUNCTION>
<FUNCTION>
<NAME>as_metadata_parse</NAME>
<RETURNS>void 			</RETURNS>
AsMetadata *metad, const gchar *data, AsFormatKind format, GError **error
</FUNCTION>
<FUNCTION>
<NAME>as_metadata_parse_desktop_data</NAME>
<RETURNS>void 			</RETURNS>
AsMetadata *metad, const gchar *data, const gchar *cid, GError **error
</FUNCTION>
<FUNCTION>
<NAME>as_metadata_get_component</NAME>
<RETURNS>AsComponent 		*</RETURNS>
AsMetadata *metad
</FUNCTION>
<FUNCTION>
<NAME>as_metadata_get_components</NAME>
<RETURNS>GPtrArray 		*</RETURNS>
AsMetadata *metad
</FUNCTION>
<FUNCTION>
<NAME>as_metadata_clear_components</NAME>
<RETURNS>void 			</RETURNS>
AsMetadata *metad
</FUNCTION>
<FUNCTION>
<NAME>as_metadata_add_component</NAME>
<RETURNS>void 			</RETURNS>
AsMetadata *metad, AsComponent *cpt
</FUNCTION>
<FUNCTION>
<NAME>as_metadata_component_to_metainfo</NAME>
<RETURNS>gchar 			*</RETURNS>
AsMetadata *metad, AsFormatKind format, GError **error
</FUNCTION>
<FUNCTION>
<NAME>as_metadata_save_metainfo</NAME>
<RETURNS>void 			</RETURNS>
AsMetadata *metad, const gchar *fname, AsFormatKind format, GError **error
</FUNCTION>
<FUNCTION>
<NAME>as_metadata_components_to_collection</NAME>
<RETURNS>gchar 			*</RETURNS>
AsMetadata *metad, AsFormatKind format, GError **error
</FUNCTION>
<FUNCTION>
<NAME>as_metadata_save_collection</NAME>
<RETURNS>void 			</RETURNS>
AsMetadata *metad, const gchar *fname, AsFormatKind format, GError **error
</FUNCTION>
<FUNCTION>
<NAME>as_metadata_get_format_version</NAME>
<RETURNS>AsFormatVersion 		</RETURNS>
AsMetadata *metad
</FUNCTION>
<FUNCTION>
<NAME>as_metadata_set_format_version</NAME>
<RETURNS>void 			</RETURNS>
AsMetadata *metad, AsFormatVersion version
</FUNCTION>
<FUNCTION>
<NAME>as_metadata_get_format_style</NAME>
<RETURNS>AsFormatStyle 		</RETURNS>
AsMetadata *metad
</FUNCTION>
<FUNCTION>
<NAME>as_metadata_set_format_style</NAME>
<RETURNS>void 			</RETURNS>
AsMetadata *metad, AsFormatStyle mode
</FUNCTION>
<FUNCTION>
<NAME>as_metadata_set_locale</NAME>
<RETURNS>void 			</RETURNS>
AsMetadata *metad, const gchar *locale
</FUNCTION>
<FUNCTION>
<NAME>as_metadata_get_locale</NAME>
<RETURNS>const gchar 		*</RETURNS>
AsMetadata *metad
</FUNCTION>
<FUNCTION>
<NAME>as_metadata_get_origin</NAME>
<RETURNS>const gchar 		*</RETURNS>
AsMetadata *metad
</FUNCTION>
<FUNCTION>
<NAME>as_metadata_set_origin</NAME>
<RETURNS>void 			</RETURNS>
AsMetadata *metad, const gchar *origin
</FUNCTION>
<FUNCTION>
<NAME>as_metadata_get_update_existing</NAME>
<RETURNS>gboolean 		</RETURNS>
AsMetadata *metad
</FUNCTION>
<FUNCTION>
<NAME>as_metadata_set_update_existing</NAME>
<RETURNS>void 			</RETURNS>
AsMetadata *metad, gboolean update
</FUNCTION>
<FUNCTION>
<NAME>as_metadata_get_write_header</NAME>
<RETURNS>gboolean 		</RETURNS>
AsMetadata *metad
</FUNCTION>
<FUNCTION>
<NAME>as_metadata_set_write_header</NAME>
<RETURNS>void 			</RETURNS>
AsMetadata *metad, gboolean wheader
</FUNCTION>
<FUNCTION>
<NAME>as_metadata_get_architecture</NAME>
<RETURNS>const gchar 		*</RETURNS>
AsMetadata *metad
</FUNCTION>
<FUNCTION>
<NAME>as_metadata_set_architecture</NAME>
<RETURNS>void 			</RETURNS>
AsMetadata *metad, const gchar *arch
</FUNCTION>
<STRUCT>
<NAME>AsMetadata</NAME>
</STRUCT>
<MACRO>
<NAME>AS_TYPE_RELEASE</NAME>
#define AS_TYPE_RELEASE (as_release_get_type ())
</MACRO>
<STRUCT>
<NAME>AsReleaseClass</NAME>
struct _AsReleaseClass
{
	GObjectClass		parent_class;
	/*< private >*/
	void (*_as_reserved1)	(void);
	void (*_as_reserved2)	(void);
	void (*_as_reserved3)	(void);
	void (*_as_reserved4)	(void);
	void (*_as_reserved5)	(void);
	void (*_as_reserved6)	(void);
};
</STRUCT>
<ENUM>
<NAME>AsSizeKind</NAME>
typedef enum {
	AS_SIZE_KIND_UNKNOWN,
	AS_SIZE_KIND_DOWNLOAD,
	AS_SIZE_KIND_INSTALLED,
	/*< private >*/
	AS_SIZE_KIND_LAST
} AsSizeKind;
</ENUM>
<FUNCTION>
<NAME>as_size_kind_to_string</NAME>
<RETURNS>const gchar 	*</RETURNS>
AsSizeKind size_kind
</FUNCTION>
<FUNCTION>
<NAME>as_size_kind_from_string</NAME>
<RETURNS>AsSizeKind 	</RETURNS>
const gchar *size_kind
</FUNCTION>
<FUNCTION>
<NAME>as_release_new</NAME>
<RETURNS>AsRelease 	*</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>as_release_get_active_locale</NAME>
<RETURNS>gchar 		*</RETURNS>
AsRelease *release
</FUNCTION>
<FUNCTION>
<NAME>as_release_set_active_locale</NAME>
<RETURNS>void 		</RETURNS>
AsRelease	*release, const gchar *locale
</FUNCTION>
<FUNCTION>
<NAME>as_release_get_version</NAME>
<RETURNS>const gchar 	*</RETURNS>
AsRelease *release
</FUNCTION>
<FUNCTION>
<NAME>as_release_set_version</NAME>
<RETURNS>void 		</RETURNS>
AsRelease *release, const gchar *version
</FUNCTION>
<FUNCTION>
<NAME>as_release_vercmp</NAME>
<RETURNS>gint 		</RETURNS>
AsRelease *rel1, AsRelease *rel2
</FUNCTION>
<FUNCTION>
<NAME>as_release_get_timestamp</NAME>
<RETURNS>guint64 		</RETURNS>
AsRelease *release
</FUNCTION>
<FUNCTION>
<NAME>as_release_set_timestamp</NAME>
<RETURNS>void 		</RETURNS>
AsRelease *release, guint64 timestamp
</FUNCTION>
<FUNCTION>
<NAME>as_release_get_description</NAME>
<RETURNS>const gchar 	*</RETURNS>
AsRelease *release
</FUNCTION>
<FUNCTION>
<NAME>as_release_set_description</NAME>
<RETURNS>void 		</RETURNS>
AsRelease *release, const gchar *description, const gchar *locale
</FUNCTION>
<FUNCTION>
<NAME>as_release_get_locations</NAME>
<RETURNS>GPtrArray 	*</RETURNS>
AsRelease *release
</FUNCTION>
<FUNCTION>
<NAME>as_release_add_location</NAME>
<RETURNS>void 		</RETURNS>
AsRelease *release, const gchar *location
</FUNCTION>
<FUNCTION>
<NAME>as_release_get_checksums</NAME>
<RETURNS>GPtrArray 	*</RETURNS>
AsRelease *release
</FUNCTION>
<FUNCTION>
<NAME>as_release_get_checksum</NAME>
<RETURNS>AsChecksum 	*</RETURNS>
AsRelease *release, AsChecksumKind kind
</FUNCTION>
<FUNCTION>
<NAME>as_release_add_checksum</NAME>
<RETURNS>void 		</RETURNS>
AsRelease *release, AsChecksum *cs
</FUNCTION>
<FUNCTION>
<NAME>as_release_get_urgency</NAME>
<RETURNS>AsUrgencyKind 	</RETURNS>
AsRelease *release
</FUNCTION>
<FUNCTION>
<NAME>as_release_set_urgency</NAME>
<RETURNS>void 		</RETURNS>
AsRelease *release, AsUrgencyKind urgency
</FUNCTION>
<FUNCTION>
<NAME>as_release_get_size</NAME>
<RETURNS>guint64 		</RETURNS>
AsRelease *release, AsSizeKind kind
</FUNCTION>
<FUNCTION>
<NAME>as_release_set_size</NAME>
<RETURNS>void 		</RETURNS>
AsRelease *release, guint64 size, AsSizeKind kind
</FUNCTION>
<STRUCT>
<NAME>AsRelease</NAME>
</STRUCT>
<MACRO>
<NAME>AS_TYPE_XMLDATA</NAME>
#define AS_TYPE_XMLDATA (as_xmldata_get_type ())
</MACRO>
<STRUCT>
<NAME>AsXMLDataClass</NAME>
struct _AsXMLDataClass
{
	GObjectClass		parent_class;
	/*< private >*/
	void (*_as_reserved1)	(void);
	void (*_as_reserved2)	(void);
	void (*_as_reserved3)	(void);
	void (*_as_reserved4)	(void);
	void (*_as_reserved5)	(void);
	void (*_as_reserved6)	(void);
};
</STRUCT>
<FUNCTION>
<NAME>as_xmldata_new</NAME>
<RETURNS>AsXMLData 		*</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>as_xmldata_initialize</NAME>
<RETURNS>void 			</RETURNS>
AsXMLData *xdt, AsFormatVersion format_version, const gchar *locale, const gchar *origin, const gchar *media_baseurl, const gchar *arch, gint priority
</FUNCTION>
<FUNCTION>
<NAME>as_xmldata_parse_metainfo_data</NAME>
<RETURNS>AsComponent 		*</RETURNS>
AsXMLData *xdt, const gchar *data, GError **error
</FUNCTION>
<FUNCTION>
<NAME>as_xmldata_parse_collection_data</NAME>
<RETURNS>GPtrArray 		*</RETURNS>
AsXMLData *xdt, const gchar *data, GError **error
</FUNCTION>
<FUNCTION>
<NAME>as_xmldata_update_cpt_with_metainfo_data</NAME>
<RETURNS>gboolean 		</RETURNS>
AsXMLData *xdt, const gchar *data, AsComponent *cpt, GError **error
</FUNCTION>
<FUNCTION>
<NAME>as_xmldata_serialize_to_metainfo</NAME>
<RETURNS>gchar 			*</RETURNS>
AsXMLData *xdt, AsComponent *cpt
</FUNCTION>
<FUNCTION>
<NAME>as_xmldata_serialize_to_collection</NAME>
<RETURNS>gchar 			*</RETURNS>
AsXMLData *xdt, GPtrArray *cpts, gboolean write_header
</FUNCTION>
<FUNCTION>
<NAME>as_xmldata_get_format_style</NAME>
<RETURNS>AsFormatStyle 		</RETURNS>
AsXMLData *xdt
</FUNCTION>
<FUNCTION>
<NAME>as_xmldata_set_format_style</NAME>
<RETURNS>void 			</RETURNS>
AsXMLData *xdt, AsFormatStyle mode
</FUNCTION>
<FUNCTION>
<NAME>as_xmldata_parse_component_node</NAME>
<RETURNS>void 			</RETURNS>
AsXMLData *metad, xmlNode *node, AsComponent *cpt, GError **error
</FUNCTION>
<FUNCTION>
<NAME>as_xmldata_parse_document</NAME>
<RETURNS>xmlDoc 			*</RETURNS>
AsXMLData *xdt, const gchar *data, GError **error
</FUNCTION>
<FUNCTION>
<NAME>as_xmldata_set_check_valid</NAME>
<RETURNS>void 			</RETURNS>
AsXMLData *xdt, gboolean check
</FUNCTION>
<STRUCT>
<NAME>AsXMLData</NAME>
</STRUCT>
<FUNCTION>
<NAME>as_desktop_entry_parse_data</NAME>
<RETURNS>AsComponent 	*</RETURNS>
const gchar *data, const gchar *cid, AsFormatVersion fversion, GError **error
</FUNCTION>
<FUNCTION>
<NAME>as_desktop_entry_parse_file</NAME>
<RETURNS>AsComponent 	*</RETURNS>
GFile *file, AsFormatVersion fversion, GError **error
</FUNCTION>
<MACRO>
<NAME>as_flags_add</NAME>
#define as_flags_add(bitfield,enum)		do { ((bitfield) |= enum); } while (0)
</MACRO>
<MACRO>
<NAME>as_flags_remove</NAME>
#define as_flags_remove(bitfield,enum)		do { ((bitfield) &= ~enum); } while (0)
</MACRO>
<MACRO>
<NAME>as_flags_invert</NAME>
#define as_flags_invert(bitfield,enum)		do { ((bitfield) ^= enum); } while (0)
</MACRO>
<MACRO>
<NAME>as_flags_contains</NAME>
#define as_flags_contains(bitfield,enum)	(((bitfield) & enum) > 0)
</MACRO>
<ENUM>
<NAME>AsUrlKind</NAME>
typedef enum {
	AS_URL_KIND_UNKNOWN,
	AS_URL_KIND_HOMEPAGE,
	AS_URL_KIND_BUGTRACKER,
	AS_URL_KIND_FAQ,
	AS_URL_KIND_HELP,
	AS_URL_KIND_DONATION,
	AS_URL_KIND_TRANSLATE,
	/*< private >*/
	AS_URL_KIND_LAST
} AsUrlKind;
</ENUM>
<FUNCTION>
<NAME>as_url_kind_to_string</NAME>
<RETURNS>const gchar 	*</RETURNS>
AsUrlKind url_kind
</FUNCTION>
<FUNCTION>
<NAME>as_url_kind_from_string</NAME>
<RETURNS>AsUrlKind 	</RETURNS>
const gchar *url_kind
</FUNCTION>
<ENUM>
<NAME>AsUrgencyKind</NAME>
typedef enum {
	AS_URGENCY_KIND_UNKNOWN,
	AS_URGENCY_KIND_LOW,
	AS_URGENCY_KIND_MEDIUM,
	AS_URGENCY_KIND_HIGH,
	AS_URGENCY_KIND_CRITICAL,
	/*< private >*/
	AS_URGENCY_KIND_LAST
} AsUrgencyKind;
</ENUM>
<FUNCTION>
<NAME>as_urgency_kind_to_string</NAME>
<RETURNS>const gchar 	*</RETURNS>
AsUrgencyKind urgency_kind
</FUNCTION>
<FUNCTION>
<NAME>as_urgency_kind_from_string</NAME>
<RETURNS>AsUrgencyKind 	 </RETURNS>
const gchar *urgency_kind
</FUNCTION>
<MACRO>
<NAME>AS_TYPE_PROVIDED</NAME>
#define AS_TYPE_PROVIDED (as_provided_get_type ())
</MACRO>
<STRUCT>
<NAME>AsProvidedClass</NAME>
struct _AsProvidedClass
{
	GObjectClass		parent_class;
	/*< private >*/
	void (*_as_reserved1)	(void);
	void (*_as_reserved2)	(void);
	void (*_as_reserved3)	(void);
	void (*_as_reserved4)	(void);
	void (*_as_reserved5)	(void);
	void (*_as_reserved6)	(void);
};
</STRUCT>
<ENUM>
<NAME>AsProvidedKind</NAME>
typedef enum  {
	AS_PROVIDED_KIND_UNKNOWN,
	AS_PROVIDED_KIND_LIBRARY,
	AS_PROVIDED_KIND_BINARY,
	AS_PROVIDED_KIND_MIMETYPE,
	AS_PROVIDED_KIND_FONT,
	AS_PROVIDED_KIND_MODALIAS,
	AS_PROVIDED_KIND_PYTHON_2,
	AS_PROVIDED_KIND_PYTHON,
	AS_PROVIDED_KIND_DBUS_SYSTEM,
	AS_PROVIDED_KIND_DBUS_USER,
	AS_PROVIDED_KIND_FIRMWARE_RUNTIME,
	AS_PROVIDED_KIND_FIRMWARE_FLASHED,
	/*< private >*/
	AS_PROVIDED_KIND_LAST
} AsProvidedKind;
</ENUM>
<FUNCTION>
<NAME>as_provided_kind_to_string</NAME>
<RETURNS>const gchar 		*</RETURNS>
AsProvidedKind kind
</FUNCTION>
<FUNCTION>
<NAME>as_provided_kind_from_string</NAME>
<RETURNS>AsProvidedKind 		</RETURNS>
const gchar *kind_str
</FUNCTION>
<FUNCTION>
<NAME>as_provided_kind_to_l10n_string</NAME>
<RETURNS>const gchar 		*</RETURNS>
AsProvidedKind kind
</FUNCTION>
<FUNCTION>
<NAME>as_provided_new</NAME>
<RETURNS>AsProvided 		*</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>as_provided_get_kind</NAME>
<RETURNS>AsProvidedKind 		</RETURNS>
AsProvided *prov
</FUNCTION>
<FUNCTION>
<NAME>as_provided_set_kind</NAME>
<RETURNS>void 			</RETURNS>
AsProvided *prov, AsProvidedKind kind
</FUNCTION>
<FUNCTION>
<NAME>as_provided_get_items</NAME>
<RETURNS>GPtrArray 		*</RETURNS>
AsProvided *prov
</FUNCTION>
<FUNCTION>
<NAME>as_provided_add_item</NAME>
<RETURNS>void 			</RETURNS>
AsProvided *prov, const gchar *item
</FUNCTION>
<FUNCTION>
<NAME>as_provided_has_item</NAME>
<RETURNS>gboolean 		</RETURNS>
AsProvided *prov, const gchar *item
</FUNCTION>
<STRUCT>
<NAME>AsProvided</NAME>
</STRUCT>
