From 28f90c3fd1926fa684370e550861a6704eb5498c Mon Sep 17 00:00:00 2001
From: Matthias Klumpp <matthias@tenstral.net>
Date: Sat, 23 Apr 2016 16:29:53 +0200
Subject: [PATCH] Refactor icon-finding code and fix rare, potential
 double-free corruption

This is a fun piece... In order to make a memory-corruption / double-
free happen, you need to:

1) Have an AppStream metainfo file with cached icon size information
2) Not have the icon that is referred to in the cache
3) Have no icon search paths set

Since the tmp_icon_path variable was not set to NULL in one occasion, a
second attempt to free it will be made.

Fortunately, the event that all three events above happen has a very low
probability (almost zero, since 3) doesn't happen unless there are other
issues).

Instead of just setting the variable to NULL, I refactored the code so
this kind of mistake doesn't happen again.
The new code will also be faster and export the stock icon property,
which apparently has been forgotten previously.
---
 qt/database.cpp               |  10 ++--
 src/as-component.c            | 115 ++++++++++++++++++++++--------------------
 src/xapian/asxentries.proto   |   7 +--
 src/xapian/database-read.cpp  |   9 ++--
 src/xapian/database-write.cpp |  11 ++--
 5 files changed, 84 insertions(+), 68 deletions(-)

diff --git a/qt/database.cpp b/qt/database.cpp
index ef002cd..989c08b 100644
--- a/qt/database.cpp
+++ b/qt/database.cpp
@@ -180,9 +180,13 @@ Component xapianDocToComponent(Xapian::Document document) {
     for (int i = 0; i < pbIcons.icon_size (); i++) {
         const Icons_Icon& pbIcon = pbIcons.icon (i);
 
-        auto size = QSize(pbIcon.width(), pbIcon.height());
-        QUrl url = QUrl::fromUserInput(QString::fromStdString(pbIcon.url()));
-        component.addIconUrl(url, size);
+        if (pbIcon.type () == Icons_IconType_STOCK) {
+            component.setIcon(QString::fromStdString(pbIcon.value()));
+        } else {
+            auto size = QSize(pbIcon.width(), pbIcon.height());
+            QUrl url = QUrl::fromUserInput(QString::fromStdString(pbIcon.value()));
+            component.addIconUrl(url, size);
+        }
     }
 
     // Summary
diff --git a/src/as-component.c b/src/as-component.c
index 843e37e..d3fcc6e 100644
--- a/src/as-component.c
+++ b/src/as-component.c
@@ -1674,7 +1674,7 @@ as_component_add_icon_full (AsComponent *cpt, AsIconKind kind, const gchar *size
 static void
 as_component_refine_icons (AsComponent *cpt, gchar **icon_paths)
 {
-	const gchar *exensions[] = { "png",
+	const gchar *extensions[] = { "png",
 				     "svg",
 				     "svgz",
 				     "gif",
@@ -1682,8 +1682,7 @@ as_component_refine_icons (AsComponent *cpt, gchar **icon_paths)
 				     "xcf",
 				     NULL };
 	const gchar *sizes[] = { "", "64x64", "128x128", NULL };
-	gchar *tmp_icon_path = NULL;
-	const gchar *icon_url = NULL;
+	const gchar *icon_fname = NULL;
 	guint i, j, k, l;
 	g_autoptr(GPtrArray) icons = NULL;
 	g_autoptr(GHashTable) icons_sizetab = NULL;
@@ -1700,63 +1699,79 @@ as_component_refine_icons (AsComponent *cpt, gchar **icon_paths)
 
 	/* Process the icons we have and extract sizes */
 	for (i = 0; i < icons->len; i++) {
+		AsIconKind ikind;
 		AsIcon *icon = AS_ICON (g_ptr_array_index (icons, i));
 
-		/* we can't do anything about remote icons (yet?), so just don't do anything to them */
-		if (as_icon_get_kind (icon) == AS_ICON_KIND_REMOTE) {
+		ikind = as_icon_get_kind (icon);
+		if (ikind == AS_ICON_KIND_REMOTE) {
+			/* no processing / icon-search is needed (and possible) for remote icons */
 			as_component_add_icon (cpt, icon);
 			continue;
+		} else if (ikind == AS_ICON_KIND_STOCK) {
+			/* since AppStream 0.9, we are not expected to find stock icon names in cache
+			 * directories anymore, so we can just add it without changes */
+			as_component_add_icon (cpt, icon);
+			continue;
+		}
+
+		if ((ikind != AS_ICON_KIND_CACHED) && (ikind != AS_ICON_KIND_LOCAL)) {
+			g_warning ("Found icon of unknown type, skipping it: %s", as_icon_kind_to_string (ikind));
+			continue;
 		}
 
-		/* get some icon name we want to resolve */
-		if (as_icon_get_kind (icon) == AS_ICON_KIND_CACHED)
-			icon_url = as_icon_get_filename (icon);
-		if (as_icon_get_kind (icon) == AS_ICON_KIND_STOCK)
-			icon_url = as_icon_get_name (icon);
+		/* get icon name we want to resolve
+		 * (it's "filename", because we should only get here if we have
+		 *  a CACHED or LOCAL icon) */
+		icon_fname = as_icon_get_filename (icon);
 
-		if (g_str_has_prefix (icon_url, "/") ||
-			g_str_has_prefix (icon_url, "http://")) {
-			/* looks like this component already has a full icon path,
-			 * or is a weblink. */
+		if (g_str_has_prefix (icon_fname, "/")) {
+			/* looks like this component already has a full icon path */
 			as_component_add_icon (cpt, icon);
+
+			/* assume 64x64px icon, if not defined otherwise */
+			if ((as_icon_get_width (icon) == 0) && (as_icon_get_height (icon) == 0)) {
+				as_icon_set_width (icon, 64);
+				as_icon_set_height (icon, 64);
+			}
+
 			continue;
 		}
 
 		/* skip the full cache search if we already have size information */
-		if (as_icon_get_kind (icon) == AS_ICON_KIND_CACHED) {
-			if (as_icon_get_width (icon) > 0) {
-				gboolean icon_found = FALSE;
-
-				for (l = 0; icon_paths[l] != NULL; l++) {
-					tmp_icon_path = g_strdup_printf ("%s/%s/%ix%i/%s",
-									icon_paths[l],
-									priv->origin,
-									as_icon_get_width (icon),
-									as_icon_get_height (icon),
-									icon_url);
-					if (g_file_test (tmp_icon_path, G_FILE_TEST_EXISTS)) {
-						as_icon_set_filename (icon, tmp_icon_path);
-						as_component_add_icon (cpt, icon);
-						icon_found = TRUE;
-					}
-					g_free (tmp_icon_path);
-					if (icon_found)
-						break;
+		if ((ikind == AS_ICON_KIND_CACHED) && (as_icon_get_width (icon) > 0)) {
+			for (l = 0; icon_paths[l] != NULL; l++) {
+				g_autofree gchar *tmp_icon_path_wh = NULL;
+				tmp_icon_path_wh = g_strdup_printf ("%s/%s/%ix%i/%s",
+								icon_paths[l],
+								priv->origin,
+								as_icon_get_width (icon),
+								as_icon_get_height (icon),
+								icon_fname);
+
+				if (g_file_test (tmp_icon_path_wh, G_FILE_TEST_EXISTS)) {
+					as_icon_set_filename (icon, tmp_icon_path_wh);
+					as_component_add_icon (cpt, icon);
+					break;
 				}
-				if (icon_found)
-					continue;
 			}
+
+			/* we don't need a full search anymore - the icon having size information means that
+			 * it will be in the "origin" subdirectory with the appropriate size, so there is no
+			 * reason to start a big icon-hunt */
+			continue;
 		}
 
 		/* search local icon path */
 		for (l = 0; icon_paths[l] != NULL; l++) {
 			for (j = 0; sizes[j] != NULL; j++) {
+				g_autofree gchar *tmp_icon_path = NULL;
 				/* sometimes, the file already has an extension */
 				tmp_icon_path = g_strdup_printf ("%s/%s/%s/%s",
 								icon_paths[l],
 								priv->origin,
 								sizes[j],
-								icon_url);
+								icon_fname);
+
 				if (g_file_test (tmp_icon_path, G_FILE_TEST_EXISTS)) {
 					/* we have an icon! */
 					if (g_strcmp0 (sizes[j], "") == 0) {
@@ -1771,48 +1786,38 @@ as_component_refine_icons (AsComponent *cpt, gchar **icon_paths)
 									    sizes[j],
 									    tmp_icon_path);
 					}
-
-					g_free (tmp_icon_path);
-					tmp_icon_path = NULL;
 					continue;
 				}
-				g_free (tmp_icon_path);
-				tmp_icon_path = NULL;
 
 				/* file not found, try extensions (we will not do this forever, better fix AppStream data!) */
-				for (k = 0; exensions[k] != NULL; k++) {
-					tmp_icon_path = g_strdup_printf ("%s/%s/%s/%s.%s",
+				for (k = 0; extensions[k] != NULL; k++) {
+					g_autofree gchar *tmp_icon_path_ext = NULL;
+					tmp_icon_path_ext = g_strdup_printf ("%s/%s/%s/%s.%s",
 								icon_paths[l],
 								priv->origin,
 								sizes[j],
-								icon_url,
-								exensions[k]);
-					if (g_file_test (tmp_icon_path, G_FILE_TEST_EXISTS)) {
+								icon_fname,
+								extensions[k]);
+
+					if (g_file_test (tmp_icon_path_ext, G_FILE_TEST_EXISTS)) {
 						/* we have an icon! */
 						if (g_strcmp0 (sizes[j], "") == 0) {
 							/* old icon directory, so assume 64x64 */
 							as_component_add_icon_full (cpt,
 									    as_icon_get_kind (icon),
 									    "64x64",
-									    tmp_icon_path);
+									    tmp_icon_path_ext);
 						} else {
 							as_component_add_icon_full (cpt,
 									    as_icon_get_kind (icon),
 									    sizes[j],
-									    tmp_icon_path);
+									    tmp_icon_path_ext);
 						}
 					}
-
-					g_free (tmp_icon_path);
-					tmp_icon_path = NULL;
 				}
 			}
 		}
 	}
-
-	if (tmp_icon_path != NULL) {
-		g_free (tmp_icon_path);
-	}
 }
 
 /**
diff --git a/src/xapian/asxentries.proto b/src/xapian/asxentries.proto
index 70a0fe2..e788949 100644
--- a/src/xapian/asxentries.proto
+++ b/src/xapian/asxentries.proto
@@ -54,15 +54,16 @@ message Bundles {
 message Icons {
   enum IconType {
     UNKNOWN = 0;
-    CACHED = 1;
-    REMOTE = 2;
+    STOCK = 1;
+    CACHED = 2;
+    REMOTE = 3;
   }
 
   message Icon {
     required IconType type = 1 [default = UNKNOWN];
     required int32 width = 2;
     required int32 height = 3;
-    required string url = 4;
+    required string value = 4;
   }
 
   repeated Icon icon = 1;
diff --git a/src/xapian/database-read.cpp b/src/xapian/database-read.cpp
index c66b9ba..85da810 100644
--- a/src/xapian/database-read.cpp
+++ b/src/xapian/database-read.cpp
@@ -182,12 +182,15 @@ DatabaseRead::docToComponent (Xapian::Document doc)
 		as_icon_set_width (icon, pbIcon.width ());
 		as_icon_set_height (icon, pbIcon.height ());
 
-		if (pbIcon.type () == Icons_IconType_REMOTE) {
+		if (pbIcon.type () == Icons_IconType_STOCK) {
+			as_icon_set_kind (icon, AS_ICON_KIND_STOCK);
+			as_icon_set_url (icon, pbIcon.value ().c_str ());
+		} else if (pbIcon.type () == Icons_IconType_REMOTE) {
 			as_icon_set_kind (icon, AS_ICON_KIND_REMOTE);
-			as_icon_set_url (icon, pbIcon.url ().c_str ());
+			as_icon_set_url (icon, pbIcon.value ().c_str ());
 		} else {
 			as_icon_set_kind (icon, AS_ICON_KIND_CACHED);
-			as_icon_set_filename (icon, pbIcon.url ().c_str ());
+			as_icon_set_filename (icon, pbIcon.value ().c_str ());
 		}
 		as_component_add_icon (cpt, icon);
 		g_object_unref (icon);
diff --git a/src/xapian/database-write.cpp b/src/xapian/database-write.cpp
index be4d389..5fe8c98 100644
--- a/src/xapian/database-write.cpp
+++ b/src/xapian/database-write.cpp
@@ -335,13 +335,16 @@ DatabaseWrite::rebuild (GList *cpt_list)
 			pbIcon->set_width (as_icon_get_width (icon));
 			pbIcon->set_height (as_icon_get_height (icon));
 
-			if (as_icon_get_kind (icon) == AS_ICON_KIND_REMOTE) {
+			if (as_icon_get_kind (icon) == AS_ICON_KIND_STOCK) {
+				pbIcon->set_type (Icons_IconType_STOCK);
+				pbIcon->set_value (as_icon_get_name (icon));
+			} else if (as_icon_get_kind (icon) == AS_ICON_KIND_REMOTE) {
 				pbIcon->set_type (Icons_IconType_REMOTE);
-				pbIcon->set_url (as_icon_get_url (icon));
+				pbIcon->set_value (as_icon_get_url (icon));
 			} else {
-				/* TODO: Properly support STOCK and LOCAL icons */
+				/* TODO: Do we want to support icons of type LOCAL? */
 				pbIcon->set_type (Icons_IconType_CACHED);
-				pbIcon->set_url (as_icon_get_filename (icon));
+				pbIcon->set_value (as_icon_get_filename (icon));
 			}
 		}
 		string icons_ostr;
